<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【Leetcode】第199场周赛</title>
    <url>/2020/07/28/%E3%80%90Leetcode%E3%80%91%E7%AC%AC199%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
    <content><![CDATA[<h2 id="A-重新排列字符串"><a href="#A-重新排列字符串" class="headerlink" title="A.重新排列字符串"></a>A.<a href="https://leetcode-cn.com/problems/shuffle-string/">重新排列字符串</a></h2><p><font size=4><strong>解题思路：</strong></font><br>开个新数组或者map存储对应序号的字符，然后按序输出。<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">restoreString</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; indices)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">char</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">            q[indices[i]]=s[i];</span><br><span class="line">        <span class="built_in">string</span> ans=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">            ans+=q[i];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="B-灯泡开关-IV"><a href="#B-灯泡开关-IV" class="headerlink" title="B.灯泡开关 IV"></a>B.<a href="https://leetcode-cn.com/problems/bulb-switcher-iv/">灯泡开关 IV</a></h2><p><font size=4><strong>解题思路：</strong></font><br>遍历灯泡数组，从前往后翻转，如果前一状态与此时状态不同，则翻转灯泡。<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minFlips</span><span class="params">(<span class="built_in">string</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> tmp[<span class="number">2</span>]=&#123;<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;target.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target[i]!=tmp[t])&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                t=<span class="number">1</span>-t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="C-好叶子节点对的数量"><a href="#C-好叶子节点对的数量" class="headerlink" title="C.好叶子节点对的数量"></a>C.<a href="https://leetcode-cn.com/problems/number-of-good-leaf-nodes-pairs/">好叶子节点对的数量</a></h2><p><font size=4><strong>解题思路：</strong></font><br>后序遍历树，每个节点返回该节点的子树中距离该节点i长度的叶节点个数的vector数组。<br>答案计算在每个节点中，加上该节点左右子树叶节点距离&lt;=distance个数的乘积和。<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans,d;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPairs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> distance)</span> </span>&#123;</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        d=distance;</span><br><span class="line">        order(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">order</span><span class="params">(TreeNode *T)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(T==<span class="literal">NULL</span>)     <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; (d+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;left==<span class="literal">NULL</span> &amp;&amp; T-&gt;right==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">q</span><span class="params">(d+<span class="number">1</span>)</span></span>;</span><br><span class="line">            q[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; le = order(T-&gt;left);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ri = order(T-&gt;right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=d;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            le[i]=le[i<span class="number">-1</span>];</span><br><span class="line">            ri[i]=ri[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        le[<span class="number">0</span>]=ri[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=d;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=d;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i+j&lt;=d)  ans+=le[i]*ri[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=d;i++)</span><br><span class="line">            le[i]+=ri[i];</span><br><span class="line">        <span class="keyword">return</span> le;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><font size=5><strong>做题情况：</strong></font><br>AC 三题<br>排名：154 / 5231<br><font size=5><strong>总结反思：</strong></font><br>这次排名较高，第三题思路出的比较快，之前几次都要八百多名，继续努力，坚持每日一刷题，争取周赛能够AK。<br>第一次写博客，以后要多写博客，分享一些做题或者学习的情况与反思。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>深度优先遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>【Leetcode】第200场周赛</title>
    <url>/2020/08/31/%E3%80%90Leetcode%E3%80%91%E7%AC%AC200%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
    <content><![CDATA[<h2 id="A-统计好三元组"><a href="#A-统计好三元组" class="headerlink" title="A.统计好三元组"></a>A.<a href="https://leetcode-cn.com/problems/count-good-triplets/">统计好三元组</a></h2><p><font size=4><strong>解题思路：</strong></font><br>三重遍历所有情况。判断三元组是否满足条件。<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countGoodTriplets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>,n=arr.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=j+<span class="number">1</span>;k&lt;n;k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">fabs</span>(arr[i]-arr[j])&lt;=a &amp;&amp; <span class="built_in">fabs</span>(arr[j]-arr[k])&lt;=b&amp;&amp;<span class="built_in">fabs</span>(arr[k]-arr[i])&lt;=c)</span><br><span class="line">                        ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="B-找出数组游戏的赢家"><a href="#B-找出数组游戏的赢家" class="headerlink" title="B.找出数组游戏的赢家"></a>B.<a href="https://leetcode-cn.com/problems/find-the-winner-of-an-array-game/">找出数组游戏的赢家</a></h2><p><font size=4><strong>解题思路：</strong></font><br>将数组转换成链表，模拟游戏过程。<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    node *next;</span><br><span class="line">    node(<span class="keyword">int</span> x)&#123;v=x;next=<span class="literal">nullptr</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getWinner</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=arr.size();</span><br><span class="line">        <span class="keyword">if</span>(k&gt;n)&#123;</span><br><span class="line">            <span class="keyword">int</span> maxv=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)    maxv=max(maxv,arr[i]);</span><br><span class="line">            <span class="keyword">return</span> maxv;</span><br><span class="line">        &#125;</span><br><span class="line">        node *root = <span class="keyword">new</span> node(arr[<span class="number">0</span>]);</span><br><span class="line">        node *p;p=root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            node *q = <span class="keyword">new</span> node(arr[i]);</span><br><span class="line">            p-&gt;next=q;</span><br><span class="line">            p=q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t==k)&#123;</span><br><span class="line">                <span class="keyword">return</span> root-&gt;v;</span><br><span class="line">            &#125;</span><br><span class="line">            node *q=root-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;v &gt; q-&gt;v)&#123;</span><br><span class="line">                t++;</span><br><span class="line">                p-&gt;next = q;</span><br><span class="line">                root-&gt;next = q-&gt;next;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                t=<span class="number">1</span>;</span><br><span class="line">                p-&gt;next = root;</span><br><span class="line">                root = q;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="C-排布二进制网格的最少交换次数"><a href="#C-排布二进制网格的最少交换次数" class="headerlink" title="C.排布二进制网格的最少交换次数"></a>C.<a href="https://leetcode-cn.com/problems/minimum-swaps-to-arrange-a-binary-grid/">排布二进制网格的最少交换次数</a></h2><p><font size=4><strong>解题思路：</strong></font><br>统计每行末尾有几个0。从0行开始，判断每一行的尾0是否满足，不满足则从后面找到最先满足的一行一行交换上来，同时ans++。最后判断网格是否满足上三角，不满足输入-1，满足输出ans。<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSwaps</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size();</span><br><span class="line">        <span class="comment">//cout&lt;&lt;n&lt;&lt;endl;</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">zenum</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=n<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="number">0</span>)   zenum[i]++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for(int i=0;i&lt;n;i++) cout&lt;&lt;zenum[i]&lt;&lt;&quot; &quot;;</span></span><br><span class="line">        <span class="comment">// cout&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(zenum[i]&gt;=n<span class="number">-1</span>-i) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(zenum[j]&gt;=n-i<span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k=j;k!=i;k--)&#123;</span><br><span class="line">                        swap(zenum[k],zenum[k<span class="number">-1</span>]);</span><br><span class="line">                        ans++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(zenum[i]&lt;n<span class="number">-1</span>-i)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="D-最大得分"><a href="#D-最大得分" class="headerlink" title="D.最大得分"></a>D.<a href="https://leetcode-cn.com/problems/get-the-maximum-score/">最大得分</a></h2><p><font size=4><strong>解题思路：</strong></font><br>按数组建图，在图上dfs。<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mymax(a,b)(a&gt;b?a:b)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2e5</span>+<span class="number">50</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,next;</span><br><span class="line">&#125;edges[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,tot,head[maxn],w[maxn];</span><br><span class="line">ll dp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    ++tot;</span><br><span class="line">    edges[tot].to=v;</span><br><span class="line">    edges[tot].next=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dp[u]) <span class="keyword">return</span> dp[u];</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=edges[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=edges[i].to;</span><br><span class="line">        ans=mymax(ans,dfs(v));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[u]=ans+w[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(edges,<span class="number">0</span>, <span class="keyword">sizeof</span>(edges));</span><br><span class="line">    <span class="built_in">memset</span>(w,<span class="number">0</span>,<span class="keyword">sizeof</span>(w));</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">    n=tot=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; getid;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> e:nums1)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!getid[e])&#123;</span><br><span class="line">                getid[e]=++cnt;</span><br><span class="line">                w[cnt]=e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> e:nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!getid[e])&#123;</span><br><span class="line">                getid[e]=++cnt;</span><br><span class="line">                w[cnt]=e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        n=cnt;</span><br><span class="line">        <span class="keyword">int</span> len1=nums1.size();</span><br><span class="line">        <span class="keyword">int</span> len2=nums2.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+<span class="number">1</span>&lt;len1;++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> u=getid[nums1[i]],v=getid[nums1[i+<span class="number">1</span>]];</span><br><span class="line">            addedge(u,v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+<span class="number">1</span>&lt;len2;++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> u=getid[nums2[i]],v=getid[nums2[i+<span class="number">1</span>]];</span><br><span class="line">            addedge(u,v);</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans=mymax(dfs(getid[nums1[<span class="number">0</span>]]),dfs(getid[nums2[<span class="number">0</span>]]));</span><br><span class="line">        <span class="keyword">return</span> ans%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><font size=5><strong>做题情况：</strong></font><br>AC 三题<br>排名：792 / 5475<br><font size=5><strong>总结反思：</strong></font><br>排名很差，第四题比赛内没有AC，有思路，一开始思路有点问题，写的不是很熟练。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>深度优先遍历</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>【Leetcode】第201场周赛</title>
    <url>/2020/09/01/%E3%80%90Leetcode%E3%80%91%E7%AC%AC201%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
    <content><![CDATA[<h2 id="A-整理字符串"><a href="#A-整理字符串" class="headerlink" title="A.整理字符串"></a>A.<a href="https://leetcode-cn.com/problems/make-the-string-great/">整理字符串</a></h2><p><font size=4><strong>解题思路：</strong></font><br>多次遍历数组，将前后字符ASCII码差值为32的两个字符删除，直到本次遍历没有改变数组。<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">makeGood</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size()==<span class="number">0</span> || s.size()==<span class="number">1</span>)  <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">bool</span> tmp=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size()<span class="number">-1</span>;)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">fabs</span>(s[i]-s[i+<span class="number">1</span>])==<span class="number">32</span>)&#123;</span><br><span class="line">                    tmp=<span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span>(i==<span class="number">0</span> &amp;&amp; s.size()==<span class="number">2</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">                    <span class="keyword">else</span> s.erase(i,<span class="number">2</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>   i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!tmp) <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="B-找出第-N-个二进制字符串中的第-K-位"><a href="#B-找出第-N-个二进制字符串中的第-K-位" class="headerlink" title="B.找出第 N 个二进制字符串中的第 K 位"></a>B.<a href="https://leetcode-cn.com/problems/find-kth-bit-in-nth-binary-string/">找出第 N 个二进制字符串中的第 K 位</a></h2><p><font size=4><strong>解题思路：</strong></font><br>模拟。每次长度变为原来的两倍+1。<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">2000000</span>];</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">findKthBit</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        s[<span class="number">1</span>]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            s[t+<span class="number">1</span>]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=t;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[j] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                    s[j+t+<span class="number">1</span>] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    s[j+t+<span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> <span class="keyword">n_t</span> =  t*<span class="number">2</span> +<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;(<span class="keyword">n_t</span> - t<span class="number">-2</span>)/<span class="number">2</span>;j++)&#123;</span><br><span class="line">                swap(s[t+<span class="number">2</span>+j],s[<span class="keyword">n_t</span>-j]);</span><br><span class="line">            &#125;</span><br><span class="line">            t = <span class="keyword">n_t</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="C-和为目标值的最大数目不重叠非空子数组数目"><a href="#C-和为目标值的最大数目不重叠非空子数组数目" class="headerlink" title="C.和为目标值的最大数目不重叠非空子数组数目"></a>C.<a href="https://leetcode-cn.com/problems/maximum-number-of-non-overlapping-subarrays-with-sum-equals-target/">和为目标值的最大数目不重叠非空子数组数目</a></h2><p><font size=4><strong>解题思路：</strong></font><br>先计算出数组的前缀和，对于第i个前缀和从0<code>~</code>i-1的前缀和找到是否有tmp = sum[i]-target。如果找到sum[j] = tmp，则找到区间j+1<code>~</code>i的区间和为target。（区间不重叠问题）最后将所有满足的区间，按右端点从小到大排序，按序选择不重叠的区间，返回区间数。<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; x,<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x.second != y.second)    <span class="keyword">return</span> x.second &lt; y.second;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> x.first&lt;y.first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sum;</span><br><span class="line">    <span class="built_in">vector</span>&lt; <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; seg;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxNonOverlapping</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        sum.resize(n);</span><br><span class="line">        sum[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            sum[i] = nums[i]+sum[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = sum[i] -target;</span><br><span class="line">            <span class="keyword">if</span>(q[tmp]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                seg.push_back(&#123;q[tmp],i&#125;);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!tmp)&#123;</span><br><span class="line">                seg.push_back(&#123;<span class="number">0</span>,i&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            q[sum[i]] = i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> nseg = seg.size();</span><br><span class="line">        sort(seg.begin(),seg.end(),cmp);</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>,n_r=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nseg;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> l = seg[i].first;</span><br><span class="line">            <span class="keyword">if</span>(l&gt;n_r)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                n_r = seg[i].second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="D-切棍子的最小成本"><a href="#D-切棍子的最小成本" class="headerlink" title="D.切棍子的最小成本"></a>D.<a href="https://leetcode-cn.com/problems/minimum-cost-to-cut-a-stick/">切棍子的最小成本</a></h2><p><font size=4><strong>解题思路：</strong></font><br>区间DP，预处理前缀和。dp[i] [j] 表示在当前待切割的木棍的左端点为 cuts[i−1]，右端点为 cuts[j] 时，将木棍全部切开的最小总成本。dp[i] [j] = min(dp[i] [j],dp[i] [k]+dp[k+1] [j]+sum[j]-sum[i-1])<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cuts)</span> </span>&#123;</span><br><span class="line">        sort(cuts.begin(),cuts.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; len_ele;</span><br><span class="line">        len_ele.push_back(<span class="number">0</span>);</span><br><span class="line">        len_ele.push_back(cuts[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;cuts.size();i++)</span><br><span class="line">            len_ele.push_back(cuts[i]-cuts[i<span class="number">-1</span>]);</span><br><span class="line">        len_ele.push_back(n-cuts[cuts.size()<span class="number">-1</span>]);</span><br><span class="line">        n = len_ele.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sum</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            sum[i] = sum[i<span class="number">-1</span>] + len_ele[i];</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n+<span class="number">2</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">2</span>,<span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">1</span>;len&lt;n ;len ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i+len&lt;=n;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> j = i+len;</span><br><span class="line">                dp[i][j] = INT_MAX;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k+<span class="number">1</span>&lt;=j;k++)&#123;</span><br><span class="line">                    dp[i][j] = min(dp[i][j],dp[i][k]+dp[k+<span class="number">1</span>][j]+sum[j]-sum[i<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><font size=5><strong>做题情况：</strong></font><br>AC 三题<br>排名：674 / 5614<br><font size=5><strong>总结反思：</strong></font><br>排名很差，比赛中第四题并没有成功AC，归结于之前没怎么写过区间DP。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>【Leetcode】第203场周赛</title>
    <url>/2020/09/03/%E3%80%90Leetcode%E3%80%91%E7%AC%AC203%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
    <content><![CDATA[<h2 id="A-圆形赛道上经过次数最多的扇区"><a href="#A-圆形赛道上经过次数最多的扇区" class="headerlink" title="A.圆形赛道上经过次数最多的扇区"></a>A.<a href="https://leetcode-cn.com/problems/most-visited-sector-in-a-circular-track/">圆形赛道上经过次数最多的扇区</a></h2><p><font size=4><strong>解题思路：</strong></font><br>模拟。<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mostVisited</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rounds)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sta = rounds[<span class="number">0</span>]<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> m = rounds.size();</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">105</span>],maxv = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">        a[sta]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;m)&#123;</span><br><span class="line">            sta = (sta + <span class="number">1</span>)%n;</span><br><span class="line">            a[sta]++;</span><br><span class="line">            maxv = max(maxv,a[sta]);</span><br><span class="line">            <span class="keyword">if</span>(sta == rounds[i]<span class="number">-1</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==maxv)  ans.push_back(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="B-你可以获得的最大硬币数目"><a href="#B-你可以获得的最大硬币数目" class="headerlink" title="B.你可以获得的最大硬币数目"></a>B.<a href="https://leetcode-cn.com/problems/maximum-number-of-coins-you-can-get/">你可以获得的最大硬币数目</a></h2><p><font size=4><strong>解题思路：</strong></font><br>从小到大排序，从倒数第二个开始取，每隔一个取一次，直到取到n/3个数，相加即可。<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; piles)</span> </span>&#123;</span><br><span class="line">        sort(piles.begin(),piles.end());</span><br><span class="line">        <span class="keyword">int</span> n = piles.size();</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>,num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=n<span class="number">-2</span>;num!=n/<span class="number">3</span>;j-=<span class="number">2</span>,num++)&#123;</span><br><span class="line">            ans+=piles[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="C-查找大小为-M-的最新分组"><a href="#C-查找大小为-M-的最新分组" class="headerlink" title="C.查找大小为 M 的最新分组"></a>C.<a href="https://leetcode-cn.com/problems/find-latest-group-of-size-m/">查找大小为 M 的最新分组</a></h2><p><font size=4><strong>解题思路：</strong></font><br>并查集。一开始每个字符为一个集合，并且每个集合内 ‘1’ 的元素个数定为0，并用数组或者map记录集合内字符 ‘1’ 个数为i(1 &lt;= i &lt;= n)的集合数。遍历数组，将对应位置字符改为 ‘1’，该集合内 ‘1’ 的元素个数修改为1 。如果左边位置为‘1’，则与左边集合合并，如果右边位置为‘1’，则与右边集合合并，并更新集合内‘1’个数 和 集合内字符 ‘1’ 个数为i(1 &lt;= i &lt;= n)的集合数。<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> pre[<span class="number">100005</span>];</span><br><span class="line">    <span class="keyword">int</span> nu[<span class="number">100005</span>];</span><br><span class="line">    <span class="keyword">int</span> val[<span class="number">100005</span>];</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r=x;</span><br><span class="line">        <span class="keyword">while</span>(r!=pre[r])</span><br><span class="line">        r=pre[r];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i=x,j;</span><br><span class="line">        <span class="keyword">while</span>(pre[i]!=j)&#123;</span><br><span class="line">            j=pre[i];</span><br><span class="line">            pre[i]=r;</span><br><span class="line">            i=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fx=find(x),fy=find(y);</span><br><span class="line">        <span class="keyword">if</span>(fx!=fy)&#123;</span><br><span class="line">            q[nu[fy]]-=<span class="number">1</span>;</span><br><span class="line">            q[nu[fx]]-=<span class="number">1</span>;</span><br><span class="line">            nu[fy]+=nu[fx];</span><br><span class="line">            pre[fx]=fy;</span><br><span class="line">        &#125;</span><br><span class="line">        q[nu[fy]]+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLatestStep</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">-1</span>,n=arr.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)    pre[i]=i,val[i]=<span class="number">0</span>,nu[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = arr[i]<span class="number">-1</span>;</span><br><span class="line">            val[x]=<span class="number">1</span>;</span><br><span class="line">            nu[x]=<span class="number">1</span>;</span><br><span class="line">            q[<span class="number">1</span>]+=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(x<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; val[x<span class="number">-1</span>]==<span class="number">1</span>)  join(x<span class="number">-1</span>,x);</span><br><span class="line">            <span class="keyword">if</span>(x+<span class="number">1</span> &lt; n &amp;&amp; val[x+<span class="number">1</span>]==<span class="number">1</span>)    join(x+<span class="number">1</span>,x);</span><br><span class="line">            <span class="keyword">if</span>(q[m]&gt;<span class="number">0</span>)  ans=i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="D-石子游戏-V"><a href="#D-石子游戏-V" class="headerlink" title="D.石子游戏 V"></a>D.<a href="https://leetcode-cn.com/problems/get-the-maximum-score/"><a href="https://leetcode-cn.com/problems/stone-game-v/">石子游戏 V</a></a></h2><p><font size=4><strong>解题思路：</strong></font><br>区间DP。预处理前缀和。dp[i] [j]表示从i<code>~</code>j这个区间内Alice所能获得的最大分数。枚举k（i &lt;= k &lt; j ),suml为区间i<code>~</code>k的和，sumr为区间k+1<code>~</code>j的和。</p>
<ul>
<li>如果suml &lt; sumr: dp[i] [j] = max(dp[i] [j],dp[i] [k] + suml)</li>
<li>如果suml &gt; sumr: dp[i] [j] = max(dp[i] [j],dp[k+1] [j] + sumr)</li>
<li>如果suml == sumr: dp[i] [j] = max(dp[i] [j],dp[i] [k] + suml ,dp[k+1] [j] + sumr)</li>
</ul>
<p><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mmax(a,b)  (((a)&gt;(b))?(a):(b))</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">stoneGameV</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stoneValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = stoneValue.size();</span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">505</span>][<span class="number">505</span>];</span><br><span class="line">        <span class="keyword">int</span> sum[<span class="number">505</span>];</span><br><span class="line">        sum[<span class="number">0</span>] = stoneValue[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)    sum[i] = sum[i<span class="number">-1</span>]+stoneValue[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l&lt;n;l++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+l&lt;n;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> j=i+l;</span><br><span class="line">                dp[i][j]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;j;k++)&#123;</span><br><span class="line">                    <span class="keyword">int</span> suml =  sum[k]-sum[i]+stoneValue[i];</span><br><span class="line">                    <span class="keyword">int</span> sumr =  sum[j]-sum[k+<span class="number">1</span>]+stoneValue[k+<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(suml&lt;sumr)&#123;</span><br><span class="line">                        dp[i][j] = mmax(dp[i][j],dp[i][k]+suml);</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(suml&gt;sumr)&#123;</span><br><span class="line">                        dp[i][j] = mmax(dp[i][j],dp[k+<span class="number">1</span>][j]+sumr);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        dp[i][j] = mmax(dp[i][j],dp[i][k]+suml);</span><br><span class="line">                        dp[i][j] = mmax(dp[i][j],dp[k+<span class="number">1</span>][j]+sumr);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><font size=5><strong>做题情况：</strong></font><br>AC 四题<br>排名：202 / 5284<br><font size=5><strong>总结反思：</strong></font><br>这场周赛总体还可以，做的很快，思路也很清晰。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>【Leetcode】第206场周赛</title>
    <url>/2020/09/14/%E3%80%90Leetcode%E3%80%91%E7%AC%AC206%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
    <content><![CDATA[<h2 id="A-二进制矩阵中的特殊位置"><a href="#A-二进制矩阵中的特殊位置" class="headerlink" title="A.二进制矩阵中的特殊位置"></a>A.<a href="https://leetcode-cn.com/problems/special-positions-in-a-binary-matrix/">二进制矩阵中的特殊位置</a></h2><p><font size=4><strong>解题思路：</strong></font><br>预处理所有行列和，遍历所有元素，如果该元素为1，并且行列和都为1，则满足要求。<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> rows[<span class="number">105</span>],cols[<span class="number">105</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSpecial</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = mat.size();</span><br><span class="line">        <span class="keyword">if</span>(!n)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = mat[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">memset</span>(rows,<span class="number">0</span>,<span class="keyword">sizeof</span>(rows));</span><br><span class="line">        <span class="built_in">memset</span>(cols,<span class="number">0</span>,<span class="keyword">sizeof</span>(cols));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                rows[i] += mat[i][j];</span><br><span class="line">                cols[j] += mat[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mat[i][j]==<span class="number">1</span> &amp;&amp; rows[i]==<span class="number">1</span> &amp;&amp; cols[j]==<span class="number">1</span>)</span><br><span class="line">                    ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="B-统计不开心的朋友"><a href="#B-统计不开心的朋友" class="headerlink" title="B.统计不开心的朋友"></a>B.<a href="https://leetcode-cn.com/problems/count-unhappy-friends/">统计不开心的朋友</a></h2><p><font size=4><strong>解题思路：</strong></font><br>模拟。<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> pei[<span class="number">505</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">unhappyFriends</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; preferences, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; pairs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = pairs[i][<span class="number">0</span>],y = pairs[i][<span class="number">1</span>];</span><br><span class="line">            pei[x] = y; pei[y] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = i,y = pei[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> u = preferences[i][j];</span><br><span class="line">                <span class="keyword">if</span>(u==y)    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">bool</span> tmp=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;</span><br><span class="line">                    <span class="keyword">int</span> v = preferences[u][k];</span><br><span class="line">                    <span class="keyword">if</span>(v == pei[u]) <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">if</span>(v==x)&#123;</span><br><span class="line">                        tmp=<span class="literal">true</span>;<span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tmp)&#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="C-连接所有点的最小费用"><a href="#C-连接所有点的最小费用" class="headerlink" title="C.连接所有点的最小费用"></a>C.<a href="https://leetcode-cn.com/problems/min-cost-to-connect-all-points/">连接所有点的最小费用</a></h2><p><font size=4><strong>解题思路：</strong></font><br>最小生成树，并查集。任意两点生成边，边长为两点的曼哈顿距离。答案即为此无向图的最小生成树的边和。最小生成树Kruskal算法：把图中的所有边按边长从小到大排序；按边长从小到大选择边，所选的边连接的两个顶点不在一个集合内，则选择此边，并将两个顶点所在集合合并，直到选择到n条边。判定是否在一个内以及集合合并采用并查集完成。<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> fa[<span class="number">1005</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> fr,to,dis;</span><br><span class="line">        node(<span class="keyword">int</span> f,<span class="keyword">int</span> t,<span class="keyword">int</span> d)&#123;</span><br><span class="line">            fr = f; to = t; dis = d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == fa[x])</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> fa[x] = find(fa[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node x,node y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x.dis&lt;y.dis;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostConnectPoints</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = points.size(),ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;node&gt; d;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> t = <span class="built_in">fabs</span>(points[i][<span class="number">0</span>]-points[j][<span class="number">0</span>])+<span class="built_in">fabs</span>(points[i][<span class="number">1</span>]-points[j][<span class="number">1</span>]);</span><br><span class="line">                d.push_back(node(i,j,t));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(d.begin(),d.end(),cmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            fa[i] = i;</span><br><span class="line">        <span class="keyword">int</span> m = d.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = find(d[i].fr), y = find(d[i].to);</span><br><span class="line">            <span class="keyword">if</span> (x != y)&#123;</span><br><span class="line">                fa[x] = y;</span><br><span class="line">                ans += d[i].dis;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="D-检查字符串是否可以通过排序子字符串得到另一个字符串"><a href="#D-检查字符串是否可以通过排序子字符串得到另一个字符串" class="headerlink" title="D. 检查字符串是否可以通过排序子字符串得到另一个字符串"></a>D.<a href="https://leetcode-cn.com/problems/check-if-string-is-transformable-with-substring-sort-operations/"> 检查字符串是否可以通过排序子字符串得到另一个字符串</a></h2><p><font size=4><strong>解题思路：</strong></font><br>贪心。逆序对的个数不能增加。预处理s中每个字符的位置，遍历t中所有字符，需要保证所有字典序小的字符不能出现在后面。</p>
<p><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isTransformable</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt; <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">ts</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">            ts[s[i]-<span class="string">&#x27;0&#x27;</span>].push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> d = t[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(ts[d].empty())   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;d;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!ts[j].empty() &amp;&amp; ts[j].front() &lt; ts[d].front()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ts[d].pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><font size=5><strong>做题情况：</strong></font><br>AC 三题<br>排名：312 / 4492<br><font size=5><strong>总结反思：</strong></font><br>第二题又读错题了，Wa了一发，第四题有大概思路，但不够完整。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>并查集</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>LCCUP力扣杯2020秋季编程大赛</title>
    <url>/2020/09/16/LCCUP%E5%8A%9B%E6%89%A3%E6%9D%AF2020%E7%A7%8B%E5%AD%A3%E7%BC%96%E7%A8%8B%E5%A4%A7%E8%B5%9B/</url>
    <content><![CDATA[<h2 id="A-速算机器人"><a href="#A-速算机器人" class="headerlink" title="A.速算机器人"></a>A.<a href="https://leetcode-cn.com/problems/nGK0Fy/">速算机器人</a></h2><p><font size=4><strong>解题思路：</strong></font><br>模拟。<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x =<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">                x = <span class="number">2</span>*x+y;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                y = <span class="number">2</span>*y+x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x+y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="B-早餐组合"><a href="#B-早餐组合" class="headerlink" title="B.早餐组合"></a>B.<a href="https://leetcode-cn.com/problems/2vYnGI/">早餐组合</a></h2><p><font size=4><strong>解题思路：</strong></font><br>二分。对drinks进行从小到大排序，遍历staple数组中每个元素，二分查找余额 x - staple[i] 的位置，即找出有多少drink可以与之搭配。<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">breakfastNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; staple, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; drinks, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        sort(staple.begin(),staple.end());</span><br><span class="line">        sort(drinks.begin(),drinks.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;staple.size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> t = upper_bound(drinks.begin(),drinks.end(),x-staple[i]) - drinks.begin();</span><br><span class="line">            ans = (ans + t)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="C-秋叶收藏集"><a href="#C-秋叶收藏集" class="headerlink" title="C.秋叶收藏集"></a>C.<a href="https://leetcode-cn.com/problems/UlBDOe/">秋叶收藏集</a></h2><p><font size=4><strong>解题思路：</strong></font><br>动态规划。dp[i] [0] 表示第i个元素为第一段r需要调整的次数，dp[i] [1] 表示第i个元素为第一段y需要调整的次数，dp[i] [2] 表示第i个元素为第二段r需要调整的次数。</p>
<ul>
<li>dp[i] [0] = dp[i-1] [0] + leaves[i] == ‘y’</li>
<li>dp[i] [1] = min(dp[i-1] [0], dp[i-1] [1]) + leaves[i] == ‘r’</li>
<li>dp[i] [2] = min(dp[i-1] [1], dp[i-1] [2]) + leaves[i] == ‘y’</li>
</ul>
<p><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mmin(x,y) (x)&lt;(y)?(x):(y)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumOperations</span><span class="params">(<span class="built_in">string</span> leaves)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = leaves.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">3</span>,<span class="number">0x3f3f3f3f</span>))</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(leaves[<span class="number">0</span>] == <span class="string">&#x27;y&#x27;</span>)    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(leaves[i] == <span class="string">&#x27;y&#x27;</span>)&#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>]+<span class="number">1</span>;</span><br><span class="line">                dp[i][<span class="number">1</span>] = min(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">                dp[i][<span class="number">2</span>] = min(dp[i<span class="number">-1</span>][<span class="number">1</span>],dp[i<span class="number">-1</span>][<span class="number">2</span>])+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] ;</span><br><span class="line">                dp[i][<span class="number">1</span>] = min(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]) +<span class="number">1</span>;</span><br><span class="line">                dp[i][<span class="number">2</span>] = min(dp[i<span class="number">-1</span>][<span class="number">1</span>],dp[i<span class="number">-1</span>][<span class="number">2</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="D-快速公交"><a href="#D-快速公交" class="headerlink" title="D.快速公交"></a>D.<a href="https://leetcode-cn.com/problems/meChtZ/">快速公交</a></h2><p><font size=4><strong>解题思路：</strong></font></p>
<p>递归。对于位置n，遍历每一个jump，n一定是从最近的前后两个jump的倍数得来。如示例1：ans[31] =ans[30] + inc or ans[31] = ans[36] - 5 *dec, 其中 ans[30] = ans[5] + cost , ans[36] = ans[6] + cost;从所有可能得到n的方式中取一个最小值。</p>
<p>需要注意，取模要在最后取，否则会改变ans的结果，并且需要map进行记忆化防止多次重复计算。</p>
<p><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mmin(x,y) (x)&lt;(y)?(x):(y)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll  mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;ll,ll&gt; ans;</span><br><span class="line">    ll in,de;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ju,co;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">busRapidTransit</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> inc, <span class="keyword">int</span> dec, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; jump, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        in = inc; de = dec; ju = jump; co = cost;</span><br><span class="line">        <span class="keyword">return</span> minCost(target)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">minCost</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(ans.count(n))    <span class="keyword">return</span> ans[n];</span><br><span class="line">        ll res = in * n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ju.size();i++)&#123;</span><br><span class="line">            ll j = ju[i],c = co[i];</span><br><span class="line">            res = mmin(res,(minCost(n/j) +c+(n%j)*in));</span><br><span class="line">            <span class="keyword">if</span>(n&gt;<span class="number">1</span> &amp;&amp; n%j) res = mmin(res,(minCost(n/j+<span class="number">1</span>) +c +(j-n%j)*de ));</span><br><span class="line">        &#125;</span><br><span class="line">        ans[n] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><font size=5><strong>做题情况：</strong></font><br>AC 三题<br>排名：324 / 3244<br><font size=5><strong>总结反思：</strong></font><br>现场只A了三题，第三题多次Wa暴露出动态规划算法的不熟练，第四题卡在了mod上。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>二分查找</tag>
        <tag>递归</tag>
      </tags>
  </entry>
</search>
