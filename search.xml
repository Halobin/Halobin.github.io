<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LCCUP力扣杯2020秋季编程大赛（个人赛）</title>
    <url>/2020/09/16/leetcode-2020-autumn-solo/</url>
    <content><![CDATA[<h2 id="A-速算机器人"><a href="#A-速算机器人" class="headerlink" title="A.速算机器人"></a>A.<a href="https://leetcode-cn.com/problems/nGK0Fy/">速算机器人</a></h2><p><font size=4><strong>解题思路：</strong></font><br>模拟。<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x =<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">                x = <span class="number">2</span>*x+y;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                y = <span class="number">2</span>*y+x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x+y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="B-早餐组合"><a href="#B-早餐组合" class="headerlink" title="B.早餐组合"></a>B.<a href="https://leetcode-cn.com/problems/2vYnGI/">早餐组合</a></h2><p><font size=4><strong>解题思路：</strong></font><br>二分。对drinks进行从小到大排序，遍历staple数组中每个元素，二分查找余额 x - staple[i] 的位置，即找出有多少drink可以与之搭配。<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">breakfastNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; staple, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; drinks, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        sort(staple.begin(),staple.end());</span><br><span class="line">        sort(drinks.begin(),drinks.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;staple.size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> t = upper_bound(drinks.begin(),drinks.end(),x-staple[i]) - drinks.begin();</span><br><span class="line">            ans = (ans + t)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="C-秋叶收藏集"><a href="#C-秋叶收藏集" class="headerlink" title="C.秋叶收藏集"></a>C.<a href="https://leetcode-cn.com/problems/UlBDOe/">秋叶收藏集</a></h2><p><font size=4><strong>解题思路：</strong></font><br>动态规划。dp[i] [0] 表示第i个元素为第一段r需要调整的次数，dp[i] [1] 表示第i个元素为第一段y需要调整的次数，dp[i] [2] 表示第i个元素为第二段r需要调整的次数。</p>
<ul>
<li>dp[i] [0] = dp[i-1] [0] + leaves[i] == ‘y’</li>
<li>dp[i] [1] = min(dp[i-1] [0], dp[i-1] [1]) + leaves[i] == ‘r’</li>
<li>dp[i] [2] = min(dp[i-1] [1], dp[i-1] [2]) + leaves[i] == ‘y’</li>
</ul>
<p><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mmin(x,y) (x)&lt;(y)?(x):(y)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumOperations</span><span class="params">(<span class="built_in">string</span> leaves)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = leaves.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">3</span>,<span class="number">0x3f3f3f3f</span>))</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(leaves[<span class="number">0</span>] == <span class="string">&#x27;y&#x27;</span>)    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(leaves[i] == <span class="string">&#x27;y&#x27;</span>)&#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>]+<span class="number">1</span>;</span><br><span class="line">                dp[i][<span class="number">1</span>] = min(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">                dp[i][<span class="number">2</span>] = min(dp[i<span class="number">-1</span>][<span class="number">1</span>],dp[i<span class="number">-1</span>][<span class="number">2</span>])+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] ;</span><br><span class="line">                dp[i][<span class="number">1</span>] = min(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]) +<span class="number">1</span>;</span><br><span class="line">                dp[i][<span class="number">2</span>] = min(dp[i<span class="number">-1</span>][<span class="number">1</span>],dp[i<span class="number">-1</span>][<span class="number">2</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="D-快速公交"><a href="#D-快速公交" class="headerlink" title="D.快速公交"></a>D.<a href="https://leetcode-cn.com/problems/meChtZ/">快速公交</a></h2><p><font size=4><strong>解题思路：</strong></font></p>
<p>递归。对于位置n，遍历每一个jump，n一定是从最近的前后两个jump的倍数得来。如示例1：ans[31] =ans[30] + inc or ans[31] = ans[36] - 5 *dec, 其中 ans[30] = ans[5] + cost , ans[36] = ans[6] + cost;从所有可能得到n的方式中取一个最小值。</p>
<p>需要注意，取模要在最后取，否则会改变ans的结果，并且需要map进行记忆化防止多次重复计算。</p>
<p><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mmin(x,y) (x)&lt;(y)?(x):(y)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll  mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;ll,ll&gt; ans;</span><br><span class="line">    ll in,de;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ju,co;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">busRapidTransit</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> inc, <span class="keyword">int</span> dec, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; jump, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        in = inc; de = dec; ju = jump; co = cost;</span><br><span class="line">        <span class="keyword">return</span> minCost(target)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">minCost</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(ans.count(n))    <span class="keyword">return</span> ans[n];</span><br><span class="line">        ll res = in * n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ju.size();i++)&#123;</span><br><span class="line">            ll j = ju[i],c = co[i];</span><br><span class="line">            res = mmin(res,(minCost(n/j) +c+(n%j)*in));</span><br><span class="line">            <span class="keyword">if</span>(n&gt;<span class="number">1</span> &amp;&amp; n%j) res = mmin(res,(minCost(n/j+<span class="number">1</span>) +c +(j-n%j)*de ));</span><br><span class="line">        &#125;</span><br><span class="line">        ans[n] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><font size=5><strong>做题情况：</strong></font><br>AC 三题<br>排名：324 / 3244<br><font size=5><strong>总结反思：</strong></font><br>现场只A了三题，第三题多次Wa暴露出动态规划算法的不熟练，第四题卡在了mod上。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
        <category>竞赛</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
        <tag>动态规划</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈单调栈</title>
    <url>/2020/10/29/mono_stack/</url>
    <content><![CDATA[<p><font size=5><strong>1、什么是单调栈？</strong></font></p>
<p>顾名思义，单调栈就是栈内元素具有单调性。分为单调递增栈和单调递减栈。</p>
<ol>
<li>单调递增栈就是从栈底到栈顶是从大到小。</li>
<li>单调递减栈就是从栈底到栈顶是从小到大。</li>
</ol>
<p>即递增递减根据出栈顺序确定，而不是在栈中数据的顺序。</p>
<p><font size=5><strong>2、单调栈的适用问题</strong></font></p>
<p>通过使用单调栈，可以找到从左/右遍历第一个比它小/大的元素的位置。也就是说在队列或数组中，我们需要通过比较前后元素的大小关系来解决问题时我们通常使用单调栈。</p>
<a id="more"></a>

<p><font size=5><strong>3、单调栈的算法流程</strong></font></p>
<p>（单调递增栈）遍历数组，维护一个栈，对于当前元素的数值如果小于栈顶元素的数值，则将其压入栈顶；否则就一直弹出栈顶，直到栈空或者当前元素的数值小于栈顶元素的数值。</p>
<p>实例 :   nums = [7,3,4,9,1,0,8,6,2]</p>
<ol>
<li>枚举第一个元素7。此时栈空，入栈。栈内元素：7。</li>
<li>枚举第二个元素3。此时栈顶元素7 &gt; 3，则入栈。栈内元素：7，3。</li>
<li>枚举第三个元素4。此时栈顶元素3 &lt; 4，则栈顶元素出栈。此时栈顶元素7 &gt; 4，则入栈。栈内元素：7，4。</li>
<li>枚举第四个元素9。此时栈顶元素4 &lt; 9，则栈顶元素出栈。此时栈顶元素7 &lt; 9，则栈顶元素出栈。此时栈空，入栈。栈内元素：9。</li>
<li>枚举第五个元素1。此时栈顶元素9 &gt; 1，则入栈。栈内元素：9，1。</li>
<li>枚举第六个元素0。此时栈顶元素1 &gt; 0，则入栈。栈内元素：9，1，0。</li>
<li>枚举第七个元素8。此时栈顶元素0 &lt; 8，则栈顶元素出栈。此时栈顶元素1 &lt; 8，则栈顶元素出栈。此时栈顶元素9 &gt; 8，则入栈。栈内元素：9，8。</li>
<li>枚举第八个元素6。此时栈顶元素8 &gt; 6，则入栈。栈内元素：9，8，6。</li>
<li>枚举第九个元素2。此时栈顶元素6 &gt; 2，则入栈。栈内元素：9，8，6，2。</li>
</ol>
<p><font size=5><strong>4、单调栈的伪代码</strong></font></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;单调递增栈</span><br><span class="line">stack&lt;int&gt; st;</span><br><span class="line">for(遍历数组)&#123;</span><br><span class="line">	while(栈不空 &amp;&amp; 栈顶元素 &lt;&#x3D; 当前元素) st.pop();</span><br><span class="line">	更新结果;</span><br><span class="line">	当前元素入栈;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font size=5><strong>5、例题</strong></font></p>
<p><font size=4>A.<a href="https://leetcode-cn.com/problems/daily-temperatures/">每日温度</a></font></p>
<p>单调递增栈，从后往前遍历数组，如果栈顶元素值小于等于当前元素值，则栈顶元素出队。直到栈空或者栈顶元素值大于当前元素值。更新结果：如果栈空，结果为0，如果不为空，结果为栈顶元素位置减去当前元素位置 。然后将当前元素入栈。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = T.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!st.empty() &amp;&amp; T[st.top()] &lt;= T[i])   st.pop();</span><br><span class="line">            ans[i] = st.empty() ? <span class="number">0</span> : st.top() - i;</span><br><span class="line">            st.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><font size=4>B.<a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">柱状图中最大的矩形</a></font></p>
<p>单调递减栈。枚举高度，对于每个高度找到前一个比它小的位置和后一个比它小的位置，这两个位置之间的所有柱子高度都小于当前元素。用两次单调递增栈分别求出左侧和右侧最近小于其高度的柱子。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = heights.size();</span><br><span class="line">        vector&lt;int&gt; left(n),right(n);</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!st.empty() &amp;&amp; heights[st.top()] &gt;= heights[i])    st.pop();</span><br><span class="line">            left[i] = st.empty() ? <span class="number">-1</span> : st.top();</span><br><span class="line">            st.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!st.empty())  st.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!st.empty() &amp;&amp; heights[st.top()] &gt;= heights[i])    st.pop();</span><br><span class="line">            right[i] = st.empty() ? n : st.top();</span><br><span class="line">            st.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            ans = max(ans,(right[i] - left[i] - <span class="number">1</span>) * heights[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><font size=5><strong>6、总结</strong></font></p>
<p>单调栈的时间复杂度是O(n)，空间复杂度是O(n)。可以用于求出左右两侧大于或者小于此元素的第一个元素。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>【Leetcode】第200场周赛</title>
    <url>/2020/08/31/weekcontest-200/</url>
    <content><![CDATA[<h2 id="A-统计好三元组"><a href="#A-统计好三元组" class="headerlink" title="A.统计好三元组"></a>A.<a href="https://leetcode-cn.com/problems/count-good-triplets/">统计好三元组</a></h2><p><font size=4><strong>解题思路：</strong></font><br>三重遍历所有情况。判断三元组是否满足条件。<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countGoodTriplets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>,n=arr.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=j+<span class="number">1</span>;k&lt;n;k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">fabs</span>(arr[i]-arr[j])&lt;=a &amp;&amp; <span class="built_in">fabs</span>(arr[j]-arr[k])&lt;=b&amp;&amp;<span class="built_in">fabs</span>(arr[k]-arr[i])&lt;=c)</span><br><span class="line">                        ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="B-找出数组游戏的赢家"><a href="#B-找出数组游戏的赢家" class="headerlink" title="B.找出数组游戏的赢家"></a>B.<a href="https://leetcode-cn.com/problems/find-the-winner-of-an-array-game/">找出数组游戏的赢家</a></h2><p><font size=4><strong>解题思路：</strong></font><br>将数组转换成链表，模拟游戏过程。<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    node *next;</span><br><span class="line">    node(<span class="keyword">int</span> x)&#123;v=x;next=<span class="literal">nullptr</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getWinner</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=arr.size();</span><br><span class="line">        <span class="keyword">if</span>(k&gt;n)&#123;</span><br><span class="line">            <span class="keyword">int</span> maxv=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)    maxv=max(maxv,arr[i]);</span><br><span class="line">            <span class="keyword">return</span> maxv;</span><br><span class="line">        &#125;</span><br><span class="line">        node *root = <span class="keyword">new</span> node(arr[<span class="number">0</span>]);</span><br><span class="line">        node *p;p=root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            node *q = <span class="keyword">new</span> node(arr[i]);</span><br><span class="line">            p-&gt;next=q;</span><br><span class="line">            p=q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t==k)&#123;</span><br><span class="line">                <span class="keyword">return</span> root-&gt;v;</span><br><span class="line">            &#125;</span><br><span class="line">            node *q=root-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;v &gt; q-&gt;v)&#123;</span><br><span class="line">                t++;</span><br><span class="line">                p-&gt;next = q;</span><br><span class="line">                root-&gt;next = q-&gt;next;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                t=<span class="number">1</span>;</span><br><span class="line">                p-&gt;next = root;</span><br><span class="line">                root = q;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="C-排布二进制网格的最少交换次数"><a href="#C-排布二进制网格的最少交换次数" class="headerlink" title="C.排布二进制网格的最少交换次数"></a>C.<a href="https://leetcode-cn.com/problems/minimum-swaps-to-arrange-a-binary-grid/">排布二进制网格的最少交换次数</a></h2><p><font size=4><strong>解题思路：</strong></font><br>统计每行末尾有几个0。从0行开始，判断每一行的尾0是否满足，不满足则从后面找到最先满足的一行一行交换上来，同时ans++。最后判断网格是否满足上三角，不满足输入-1，满足输出ans。<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSwaps</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size();</span><br><span class="line">        <span class="comment">//cout&lt;&lt;n&lt;&lt;endl;</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">zenum</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=n<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="number">0</span>)   zenum[i]++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for(int i=0;i&lt;n;i++) cout&lt;&lt;zenum[i]&lt;&lt;&quot; &quot;;</span></span><br><span class="line">        <span class="comment">// cout&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(zenum[i]&gt;=n<span class="number">-1</span>-i) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(zenum[j]&gt;=n-i<span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k=j;k!=i;k--)&#123;</span><br><span class="line">                        swap(zenum[k],zenum[k<span class="number">-1</span>]);</span><br><span class="line">                        ans++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(zenum[i]&lt;n<span class="number">-1</span>-i)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="D-最大得分"><a href="#D-最大得分" class="headerlink" title="D.最大得分"></a>D.<a href="https://leetcode-cn.com/problems/get-the-maximum-score/">最大得分</a></h2><p><font size=4><strong>解题思路：</strong></font><br>按数组建图，在图上dfs。<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mymax(a,b)(a&gt;b?a:b)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2e5</span>+<span class="number">50</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,next;</span><br><span class="line">&#125;edges[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,tot,head[maxn],w[maxn];</span><br><span class="line">ll dp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    ++tot;</span><br><span class="line">    edges[tot].to=v;</span><br><span class="line">    edges[tot].next=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dp[u]) <span class="keyword">return</span> dp[u];</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=edges[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=edges[i].to;</span><br><span class="line">        ans=mymax(ans,dfs(v));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[u]=ans+w[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(edges,<span class="number">0</span>, <span class="keyword">sizeof</span>(edges));</span><br><span class="line">    <span class="built_in">memset</span>(w,<span class="number">0</span>,<span class="keyword">sizeof</span>(w));</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">    n=tot=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; getid;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> e:nums1)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!getid[e])&#123;</span><br><span class="line">                getid[e]=++cnt;</span><br><span class="line">                w[cnt]=e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> e:nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!getid[e])&#123;</span><br><span class="line">                getid[e]=++cnt;</span><br><span class="line">                w[cnt]=e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        n=cnt;</span><br><span class="line">        <span class="keyword">int</span> len1=nums1.size();</span><br><span class="line">        <span class="keyword">int</span> len2=nums2.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+<span class="number">1</span>&lt;len1;++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> u=getid[nums1[i]],v=getid[nums1[i+<span class="number">1</span>]];</span><br><span class="line">            addedge(u,v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+<span class="number">1</span>&lt;len2;++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> u=getid[nums2[i]],v=getid[nums2[i+<span class="number">1</span>]];</span><br><span class="line">            addedge(u,v);</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans=mymax(dfs(getid[nums1[<span class="number">0</span>]]),dfs(getid[nums2[<span class="number">0</span>]]));</span><br><span class="line">        <span class="keyword">return</span> ans%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><font size=5><strong>做题情况：</strong></font><br>AC 三题<br>排名：792 / 5475<br><font size=5><strong>总结反思：</strong></font><br>排名很差，第四题比赛内没有AC，有思路，一开始思路有点问题，写的不是很熟练。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>深度优先遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>【Leetcode】第203场周赛</title>
    <url>/2020/09/03/weekcontest-203/</url>
    <content><![CDATA[<h2 id="A-圆形赛道上经过次数最多的扇区"><a href="#A-圆形赛道上经过次数最多的扇区" class="headerlink" title="A.圆形赛道上经过次数最多的扇区"></a>A.<a href="https://leetcode-cn.com/problems/most-visited-sector-in-a-circular-track/">圆形赛道上经过次数最多的扇区</a></h2><p><font size=4><strong>解题思路：</strong></font><br>模拟。<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mostVisited</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rounds)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sta = rounds[<span class="number">0</span>]<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> m = rounds.size();</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">105</span>],maxv = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">        a[sta]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;m)&#123;</span><br><span class="line">            sta = (sta + <span class="number">1</span>)%n;</span><br><span class="line">            a[sta]++;</span><br><span class="line">            maxv = max(maxv,a[sta]);</span><br><span class="line">            <span class="keyword">if</span>(sta == rounds[i]<span class="number">-1</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==maxv)  ans.push_back(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="B-你可以获得的最大硬币数目"><a href="#B-你可以获得的最大硬币数目" class="headerlink" title="B.你可以获得的最大硬币数目"></a>B.<a href="https://leetcode-cn.com/problems/maximum-number-of-coins-you-can-get/">你可以获得的最大硬币数目</a></h2><p><font size=4><strong>解题思路：</strong></font><br>从小到大排序，从倒数第二个开始取，每隔一个取一次，直到取到n/3个数，相加即可。<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; piles)</span> </span>&#123;</span><br><span class="line">        sort(piles.begin(),piles.end());</span><br><span class="line">        <span class="keyword">int</span> n = piles.size();</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>,num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=n<span class="number">-2</span>;num!=n/<span class="number">3</span>;j-=<span class="number">2</span>,num++)&#123;</span><br><span class="line">            ans+=piles[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="C-查找大小为-M-的最新分组"><a href="#C-查找大小为-M-的最新分组" class="headerlink" title="C.查找大小为 M 的最新分组"></a>C.<a href="https://leetcode-cn.com/problems/find-latest-group-of-size-m/">查找大小为 M 的最新分组</a></h2><p><font size=4><strong>解题思路：</strong></font><br>并查集。一开始每个字符为一个集合，并且每个集合内 ‘1’ 的元素个数定为0，并用数组或者map记录集合内字符 ‘1’ 个数为i(1 &lt;= i &lt;= n)的集合数。遍历数组，将对应位置字符改为 ‘1’，该集合内 ‘1’ 的元素个数修改为1 。如果左边位置为‘1’，则与左边集合合并，如果右边位置为‘1’，则与右边集合合并，并更新集合内‘1’个数 和 集合内字符 ‘1’ 个数为i(1 &lt;= i &lt;= n)的集合数。<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> pre[<span class="number">100005</span>];</span><br><span class="line">    <span class="keyword">int</span> nu[<span class="number">100005</span>];</span><br><span class="line">    <span class="keyword">int</span> val[<span class="number">100005</span>];</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r=x;</span><br><span class="line">        <span class="keyword">while</span>(r!=pre[r])</span><br><span class="line">        r=pre[r];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i=x,j;</span><br><span class="line">        <span class="keyword">while</span>(pre[i]!=j)&#123;</span><br><span class="line">            j=pre[i];</span><br><span class="line">            pre[i]=r;</span><br><span class="line">            i=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fx=find(x),fy=find(y);</span><br><span class="line">        <span class="keyword">if</span>(fx!=fy)&#123;</span><br><span class="line">            q[nu[fy]]-=<span class="number">1</span>;</span><br><span class="line">            q[nu[fx]]-=<span class="number">1</span>;</span><br><span class="line">            nu[fy]+=nu[fx];</span><br><span class="line">            pre[fx]=fy;</span><br><span class="line">        &#125;</span><br><span class="line">        q[nu[fy]]+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLatestStep</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">-1</span>,n=arr.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)    pre[i]=i,val[i]=<span class="number">0</span>,nu[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = arr[i]<span class="number">-1</span>;</span><br><span class="line">            val[x]=<span class="number">1</span>;</span><br><span class="line">            nu[x]=<span class="number">1</span>;</span><br><span class="line">            q[<span class="number">1</span>]+=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(x<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; val[x<span class="number">-1</span>]==<span class="number">1</span>)  join(x<span class="number">-1</span>,x);</span><br><span class="line">            <span class="keyword">if</span>(x+<span class="number">1</span> &lt; n &amp;&amp; val[x+<span class="number">1</span>]==<span class="number">1</span>)    join(x+<span class="number">1</span>,x);</span><br><span class="line">            <span class="keyword">if</span>(q[m]&gt;<span class="number">0</span>)  ans=i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="D-石子游戏-V"><a href="#D-石子游戏-V" class="headerlink" title="D.石子游戏 V"></a>D.<a href="https://leetcode-cn.com/problems/get-the-maximum-score/"><a href="https://leetcode-cn.com/problems/stone-game-v/">石子游戏 V</a></a></h2><p><font size=4><strong>解题思路：</strong></font><br>区间DP。预处理前缀和。dp[i] [j]表示从i<code>~</code>j这个区间内Alice所能获得的最大分数。枚举k（i &lt;= k &lt; j ),suml为区间i<code>~</code>k的和，sumr为区间k+1<code>~</code>j的和。</p>
<ul>
<li>如果suml &lt; sumr: dp[i] [j] = max(dp[i] [j],dp[i] [k] + suml)</li>
<li>如果suml &gt; sumr: dp[i] [j] = max(dp[i] [j],dp[k+1] [j] + sumr)</li>
<li>如果suml == sumr: dp[i] [j] = max(dp[i] [j],dp[i] [k] + suml ,dp[k+1] [j] + sumr)</li>
</ul>
<p><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mmax(a,b)  (((a)&gt;(b))?(a):(b))</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">stoneGameV</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stoneValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = stoneValue.size();</span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">505</span>][<span class="number">505</span>];</span><br><span class="line">        <span class="keyword">int</span> sum[<span class="number">505</span>];</span><br><span class="line">        sum[<span class="number">0</span>] = stoneValue[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)    sum[i] = sum[i<span class="number">-1</span>]+stoneValue[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l&lt;n;l++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+l&lt;n;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> j=i+l;</span><br><span class="line">                dp[i][j]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;j;k++)&#123;</span><br><span class="line">                    <span class="keyword">int</span> suml =  sum[k]-sum[i]+stoneValue[i];</span><br><span class="line">                    <span class="keyword">int</span> sumr =  sum[j]-sum[k+<span class="number">1</span>]+stoneValue[k+<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(suml&lt;sumr)&#123;</span><br><span class="line">                        dp[i][j] = mmax(dp[i][j],dp[i][k]+suml);</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(suml&gt;sumr)&#123;</span><br><span class="line">                        dp[i][j] = mmax(dp[i][j],dp[k+<span class="number">1</span>][j]+sumr);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        dp[i][j] = mmax(dp[i][j],dp[i][k]+suml);</span><br><span class="line">                        dp[i][j] = mmax(dp[i][j],dp[k+<span class="number">1</span>][j]+sumr);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><font size=5><strong>做题情况：</strong></font><br>AC 四题<br>排名：202 / 5284<br><font size=5><strong>总结反思：</strong></font><br>这场周赛总体还可以，做的很快，思路也很清晰。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>【Leetcode】第206场周赛</title>
    <url>/2020/09/14/weekcontest-206/</url>
    <content><![CDATA[<h2 id="A-二进制矩阵中的特殊位置"><a href="#A-二进制矩阵中的特殊位置" class="headerlink" title="A.二进制矩阵中的特殊位置"></a>A.<a href="https://leetcode-cn.com/problems/special-positions-in-a-binary-matrix/">二进制矩阵中的特殊位置</a></h2><p><font size=4><strong>解题思路：</strong></font><br>预处理所有行列和，遍历所有元素，如果该元素为1，并且行列和都为1，则满足要求。<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> rows[<span class="number">105</span>],cols[<span class="number">105</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSpecial</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = mat.size();</span><br><span class="line">        <span class="keyword">if</span>(!n)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = mat[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">memset</span>(rows,<span class="number">0</span>,<span class="keyword">sizeof</span>(rows));</span><br><span class="line">        <span class="built_in">memset</span>(cols,<span class="number">0</span>,<span class="keyword">sizeof</span>(cols));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                rows[i] += mat[i][j];</span><br><span class="line">                cols[j] += mat[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mat[i][j]==<span class="number">1</span> &amp;&amp; rows[i]==<span class="number">1</span> &amp;&amp; cols[j]==<span class="number">1</span>)</span><br><span class="line">                    ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="B-统计不开心的朋友"><a href="#B-统计不开心的朋友" class="headerlink" title="B.统计不开心的朋友"></a>B.<a href="https://leetcode-cn.com/problems/count-unhappy-friends/">统计不开心的朋友</a></h2><p><font size=4><strong>解题思路：</strong></font><br>模拟。<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> pei[<span class="number">505</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">unhappyFriends</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; preferences, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; pairs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = pairs[i][<span class="number">0</span>],y = pairs[i][<span class="number">1</span>];</span><br><span class="line">            pei[x] = y; pei[y] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = i,y = pei[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> u = preferences[i][j];</span><br><span class="line">                <span class="keyword">if</span>(u==y)    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">bool</span> tmp=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;</span><br><span class="line">                    <span class="keyword">int</span> v = preferences[u][k];</span><br><span class="line">                    <span class="keyword">if</span>(v == pei[u]) <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">if</span>(v==x)&#123;</span><br><span class="line">                        tmp=<span class="literal">true</span>;<span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tmp)&#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="C-连接所有点的最小费用"><a href="#C-连接所有点的最小费用" class="headerlink" title="C.连接所有点的最小费用"></a>C.<a href="https://leetcode-cn.com/problems/min-cost-to-connect-all-points/">连接所有点的最小费用</a></h2><p><font size=4><strong>解题思路：</strong></font><br>最小生成树，并查集。任意两点生成边，边长为两点的曼哈顿距离。答案即为此无向图的最小生成树的边和。最小生成树Kruskal算法：把图中的所有边按边长从小到大排序；按边长从小到大选择边，所选的边连接的两个顶点不在一个集合内，则选择此边，并将两个顶点所在集合合并，直到选择到n条边。判定是否在一个内以及集合合并采用并查集完成。<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> fa[<span class="number">1005</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> fr,to,dis;</span><br><span class="line">        node(<span class="keyword">int</span> f,<span class="keyword">int</span> t,<span class="keyword">int</span> d)&#123;</span><br><span class="line">            fr = f; to = t; dis = d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == fa[x])</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> fa[x] = find(fa[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node x,node y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x.dis&lt;y.dis;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostConnectPoints</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = points.size(),ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;node&gt; d;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> t = <span class="built_in">fabs</span>(points[i][<span class="number">0</span>]-points[j][<span class="number">0</span>])+<span class="built_in">fabs</span>(points[i][<span class="number">1</span>]-points[j][<span class="number">1</span>]);</span><br><span class="line">                d.push_back(node(i,j,t));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(d.begin(),d.end(),cmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            fa[i] = i;</span><br><span class="line">        <span class="keyword">int</span> m = d.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = find(d[i].fr), y = find(d[i].to);</span><br><span class="line">            <span class="keyword">if</span> (x != y)&#123;</span><br><span class="line">                fa[x] = y;</span><br><span class="line">                ans += d[i].dis;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="D-检查字符串是否可以通过排序子字符串得到另一个字符串"><a href="#D-检查字符串是否可以通过排序子字符串得到另一个字符串" class="headerlink" title="D. 检查字符串是否可以通过排序子字符串得到另一个字符串"></a>D.<a href="https://leetcode-cn.com/problems/check-if-string-is-transformable-with-substring-sort-operations/"> 检查字符串是否可以通过排序子字符串得到另一个字符串</a></h2><p><font size=4><strong>解题思路：</strong></font><br>贪心。逆序对的个数不能增加。预处理s中每个字符的位置，遍历t中所有字符，需要保证所有字典序小的字符不能出现在后面。</p>
<p><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isTransformable</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt; <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">ts</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">            ts[s[i]-<span class="string">&#x27;0&#x27;</span>].push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> d = t[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(ts[d].empty())   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;d;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!ts[j].empty() &amp;&amp; ts[j].front() &lt; ts[d].front()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ts[d].pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><font size=5><strong>做题情况：</strong></font><br>AC 三题<br>排名：312 / 4492<br><font size=5><strong>总结反思：</strong></font><br>第二题又读错题了，Wa了一发，第四题有大概思路，但不够完整。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>并查集</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>【Leetcode】第207场周赛</title>
    <url>/2020/09/25/weekcontest-207/</url>
    <content><![CDATA[<h2 id="A-重新排列单词间的空格"><a href="#A-重新排列单词间的空格" class="headerlink" title="A.重新排列单词间的空格"></a>A.<a href="https://leetcode-cn.com/problems/rearrange-spaces-between-words/">重新排列单词间的空格</a></h2><p><font size=4><strong>解题思路：</strong></font><br>模拟。统计空格数以及单词数。<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reorderSpaces</span><span class="params">(<span class="built_in">string</span> text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>, n = text.size(), i;</span><br><span class="line">        <span class="built_in">string</span> t = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; word;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(text[i]==<span class="string">&#x27; &#x27;</span>)    k++;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                t += text[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(++i;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(text[i] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                k++;</span><br><span class="line">                <span class="keyword">if</span>(t!=<span class="string">&quot;&quot;</span>)   &#123;</span><br><span class="line">                    word.push_back(t);</span><br><span class="line">                    t = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                t += text[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t!=<span class="string">&quot;&quot;</span>)   word.push_back(t);</span><br><span class="line">        <span class="keyword">int</span> w = word.size();</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        ans += word[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(w == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">                ans += <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;w;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k/(w<span class="number">-1</span>);j++)</span><br><span class="line">                    ans+=<span class="string">&quot; &quot;</span>;</span><br><span class="line">                ans += word[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k%(w<span class="number">-1</span>);j++)</span><br><span class="line">                ans += <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="B-拆分字符串使唯一子字符串的数目最大"><a href="#B-拆分字符串使唯一子字符串的数目最大" class="headerlink" title="B.拆分字符串使唯一子字符串的数目最大"></a>B.<a href="https://leetcode-cn.com/problems/split-a-string-into-the-max-number-of-unique-substrings/">拆分字符串使唯一子字符串的数目最大</a></h2><p><font size=4><strong>解题思路：</strong></font><br>暴力枚举。递归搜索每一种情况。<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mmax(x,y) (x)&gt;(y)?(x):(y)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>,n;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; dic;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxUniqueSplit</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;s = s;</span><br><span class="line">        n = s.size();</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t == n)&#123;</span><br><span class="line">            ans = mmax(ans,dic.size());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> tmp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=t;i&lt;n;i++)&#123;</span><br><span class="line">            tmp += s[i];</span><br><span class="line">            <span class="keyword">if</span>(!dic.count(tmp))&#123;</span><br><span class="line">                dic[tmp]+=<span class="number">1</span>;</span><br><span class="line">                dfs(i+<span class="number">1</span>);</span><br><span class="line">                dic.erase(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="C-矩阵的最大非负积"><a href="#C-矩阵的最大非负积" class="headerlink" title="C.矩阵的最大非负积"></a>C.<a href="https://leetcode-cn.com/problems/maximum-non-negative-product-in-a-matrix/">矩阵的最大非负积</a></h2><p><font size=4><strong>解题思路：</strong></font><br>递归。枚举所有情况，遇到0剪枝。<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mmax(x,y) (x)&gt;(y)?(x):(y)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> ll mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    ll ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> r,c;</span><br><span class="line">    <span class="keyword">int</span> grid[<span class="number">16</span>][<span class="number">16</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProductPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        r = grid.size(), c = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;r;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;c;j++)    <span class="keyword">this</span>-&gt;grid[i][j] = grid[i][j];</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,ll k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == r || j == c)    <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(!grid[i][j])&#123;</span><br><span class="line">            ans = mmax(ans,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        k = k * grid[i][j];</span><br><span class="line">        <span class="keyword">if</span>(i == r<span class="number">-1</span> &amp;&amp; j == c<span class="number">-1</span>)&#123;</span><br><span class="line">            ans = mmax(ans,k);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(i+<span class="number">1</span>,j,k);</span><br><span class="line">        dfs(i,j+<span class="number">1</span>,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><font size=5><strong>做题情况：</strong></font><br>AC 三题<br>排名：428 / 4115<br><font size=5><strong>总结反思：</strong></font><br>做的很差，二三题都不难，卡了有点久。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>【Leetcode】第210场周赛</title>
    <url>/2020/10/17/weekcontest-210/</url>
    <content><![CDATA[<h2 id="A-括号的最大嵌套深度"><a href="#A-括号的最大嵌套深度" class="headerlink" title="A.括号的最大嵌套深度"></a>A.<a href="https://leetcode-cn.com/problems/maximum-nesting-depth-of-the-parentheses/">括号的最大嵌套深度</a></h2><p><font size=4><strong>解题思路：</strong></font><br>模拟。<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size(),ans = <span class="number">0</span>,t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                t++;</span><br><span class="line">                ans = max(ans,t);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                t--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="B-最大网络秩"><a href="#B-最大网络秩" class="headerlink" title="B.最大网络秩"></a>B.<a href="https://leetcode-cn.com/problems/maximal-network-rank/">最大网络秩</a></h2><p><font size=4><strong>解题思路：</strong></font><br>用邻接矩阵记录两个城市是否有道路，并记录每个城市相连的道路条数。暴力枚举城市对，算出这个城市对的答案为两个城市相连道路条数和并减去两个城市互连的道路。最大网络秩为各个城市对答案的最大值。<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; isr;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalNetworkRank</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; roads)</span> </span>&#123;</span><br><span class="line">        isr.resize(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">        nums.resize(n,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; roads.size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = roads[i][<span class="number">0</span>], y = roads[i][<span class="number">1</span>];</span><br><span class="line">            isr[x][y] = isr[y][x] = <span class="number">1</span>;</span><br><span class="line">            nums[x]++;  nums[y]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>;j &lt; n;j++)&#123;</span><br><span class="line">                ans = max(ans,nums[i] + nums[j] - isr[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="C-分割两个字符串得到回文串"><a href="#C-分割两个字符串得到回文串" class="headerlink" title="C.分割两个字符串得到回文串"></a>C.<a href="https://leetcode-cn.com/problems/split-two-strings-to-make-palindrome/">分割两个字符串得到回文串</a></h2><p>解题思路：<br>从字符串A中心找最大回文串，以此划分A字符串为A<sub>le</sub> A<sub>mid</sub>A<sub>ri</sub>，以相同位置划分B为B<sub>le</sub> B<sub>mid</sub>B<sub>ri</sub>。如果A<sub>le</sub> + B<sub>ri</sub> 或者 B<sub>le</sub>+A<sub>ri</sub> 为回文串，则分割这两个字符串可以得到回文串。同理寻找B的中心回文串，以此来划分A和B字符串，判断A<sub>le</sub> + B<sub>ri</sub> 或者 B<sub>le</sub>+A<sub>ri</sub> 是否为回文串。如果都不是，则分割这两个字符串不可以得到回文串。<br>代码展示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkPalindromeFormation</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.size(),midl,midr;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        midl = (n - <span class="number">2</span>) / <span class="number">2</span>;midr = midl + <span class="number">1</span> + n % <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(midl &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[midl] != a[midr])  <span class="keyword">break</span>;</span><br><span class="line">            midl--;midr++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(midl &lt; <span class="number">0</span>)    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">string</span> s1 = a.substr(<span class="number">0</span>,midl + <span class="number">1</span>), s2 = a.substr(midr,n - midr);</span><br><span class="line">        <span class="built_in">string</span> s3 = b.substr(<span class="number">0</span>,midl + <span class="number">1</span>), s4 = b.substr(midr,n - midr);</span><br><span class="line">        reverse(s2.begin(),s2.end());</span><br><span class="line">        reverse(s4.begin(),s4.end());</span><br><span class="line">        <span class="keyword">if</span>(s1 == s4 || s2 == s3)    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        midl = (n - <span class="number">2</span>) / <span class="number">2</span>;midr = midl + <span class="number">1</span> + n % <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(midl &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(b[midl] != b[midr])  <span class="keyword">break</span>;</span><br><span class="line">            midl--;midr++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(midl &lt; <span class="number">0</span>)    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        s1 = a.substr(<span class="number">0</span>,midl + <span class="number">1</span>), s2 = a.substr(midr,n - midr);</span><br><span class="line">        s3 = b.substr(<span class="number">0</span>,midl + <span class="number">1</span>), s4 = b.substr(midr,n - midr);</span><br><span class="line">        reverse(s2.begin(),s2.end());</span><br><span class="line">        reverse(s4.begin(),s4.end());</span><br><span class="line">        <span class="keyword">if</span>(s1 == s4 || s2 == s3)    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="D-统计子树中城市之间最大距离"><a href="#D-统计子树中城市之间最大距离" class="headerlink" title="D.统计子树中城市之间最大距离"></a>D.<a href="https://leetcode-cn.com/problems/count-subtrees-with-max-distance-between-cities/">统计子树中城市之间最大距离</a></h2><p><font size=4><strong>解题思路：</strong></font><br>二进制枚举，最短路。一共只有十五个城市，二进制枚举所有可能情况。先判断枚举的城市组合是否是连通的。如果是连通的，则以每个城市为起点，用广度优先搜索算法计算一次最短路。</p>
<p><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vis;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; edges;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max_dis</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>,eds=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">e</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; edges.size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = edges[i][<span class="number">0</span>], y = edges[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(vis[x] &amp;&amp; vis[y])&#123;</span><br><span class="line">                eds++;</span><br><span class="line">                e[x].push_back(y); e[y].push_back(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; vis.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i])  t++;</span><br><span class="line">            <span class="keyword">if</span>(vis[i] &amp;&amp; e[i].size() == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t != eds+<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; vis.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i])&#123;</span><br><span class="line">                v = vis;</span><br><span class="line">                <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">                q.push(&#123;i,<span class="number">0</span>&#125;);</span><br><span class="line">                v[i] = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">                    <span class="keyword">auto</span> t = q.front();</span><br><span class="line">                    q.pop();</span><br><span class="line">                    <span class="keyword">int</span> x = t.first, d = t.second;</span><br><span class="line">                    res = max(res,d);</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; e[x].size();j++)&#123;</span><br><span class="line">                        <span class="keyword">int</span> to = e[x][j];</span><br><span class="line">                        <span class="keyword">if</span>(v[to])&#123;</span><br><span class="line">                            v[to] = <span class="literal">false</span>;</span><br><span class="line">                            q.push(&#123;to,d+<span class="number">1</span>&#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countSubgraphsForEachDiameter</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        ans.resize(n<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">        vis.resize(n);</span><br><span class="line">        <span class="keyword">int</span> e = edges.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; e;i++)&#123;</span><br><span class="line">            edges[i][<span class="number">0</span>]--;</span><br><span class="line">            edges[i][<span class="number">1</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;edges = edges;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (<span class="number">1</span>&lt;&lt;n);i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++) vis[j] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i &amp; (<span class="number">1</span> &lt;&lt; j))&#123;</span><br><span class="line">                    vis[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> res = max_dis();</span><br><span class="line">            <span class="keyword">if</span>(res&gt;=<span class="number">1</span>) ans[res<span class="number">-1</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><font size=5><strong>做题情况：</strong></font><br>AC 三题<br>排名：291 / 4006<br><font size=5><strong>总结反思：</strong></font><br>前三题写的还行，第四题一开始没想到二进制枚举，写起来也比较生疏，导致最后也没写完。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>二进制枚举</tag>
        <tag>最短路</tag>
        <tag>广度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>【Leetcode】第199场周赛</title>
    <url>/2020/07/28/weekcontest-199/</url>
    <content><![CDATA[<h2 id="A-重新排列字符串"><a href="#A-重新排列字符串" class="headerlink" title="A.重新排列字符串"></a>A.<a href="https://leetcode-cn.com/problems/shuffle-string/">重新排列字符串</a></h2><p><font size=4><strong>解题思路：</strong></font><br>开个新数组或者map存储对应序号的字符，然后按序输出。<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">restoreString</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; indices)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">char</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">            q[indices[i]]=s[i];</span><br><span class="line">        <span class="built_in">string</span> ans=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">            ans+=q[i];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="B-灯泡开关-IV"><a href="#B-灯泡开关-IV" class="headerlink" title="B.灯泡开关 IV"></a>B.<a href="https://leetcode-cn.com/problems/bulb-switcher-iv/">灯泡开关 IV</a></h2><p><font size=4><strong>解题思路：</strong></font><br>遍历灯泡数组，从前往后翻转，如果前一状态与此时状态不同，则翻转灯泡。<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minFlips</span><span class="params">(<span class="built_in">string</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> tmp[<span class="number">2</span>]=&#123;<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;target.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target[i]!=tmp[t])&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                t=<span class="number">1</span>-t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="C-好叶子节点对的数量"><a href="#C-好叶子节点对的数量" class="headerlink" title="C.好叶子节点对的数量"></a>C.<a href="https://leetcode-cn.com/problems/number-of-good-leaf-nodes-pairs/">好叶子节点对的数量</a></h2><p><font size=4><strong>解题思路：</strong></font><br>后序遍历树，每个节点返回该节点的子树中距离该节点i长度的叶节点个数的vector数组。<br>答案计算在每个节点中，加上该节点左右子树叶节点距离&lt;=distance个数的乘积和。<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans,d;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPairs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> distance)</span> </span>&#123;</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        d=distance;</span><br><span class="line">        order(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">order</span><span class="params">(TreeNode *T)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(T==<span class="literal">NULL</span>)     <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; (d+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;left==<span class="literal">NULL</span> &amp;&amp; T-&gt;right==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">q</span><span class="params">(d+<span class="number">1</span>)</span></span>;</span><br><span class="line">            q[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; le = order(T-&gt;left);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ri = order(T-&gt;right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=d;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            le[i]=le[i<span class="number">-1</span>];</span><br><span class="line">            ri[i]=ri[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        le[<span class="number">0</span>]=ri[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=d;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=d;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i+j&lt;=d)  ans+=le[i]*ri[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=d;i++)</span><br><span class="line">            le[i]+=ri[i];</span><br><span class="line">        <span class="keyword">return</span> le;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><font size=5><strong>做题情况：</strong></font><br>AC 三题<br>排名：154 / 5231<br><font size=5><strong>总结反思：</strong></font><br>这次排名较高，第三题思路出的比较快，之前几次都要八百多名，继续努力，坚持每日一刷题，争取周赛能够AK。<br>第一次写博客，以后要多写博客，分享一些做题或者学习的情况与反思。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>深度优先遍历</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>【Leetcode】第201场周赛</title>
    <url>/2020/09/01/weekcontest-201/</url>
    <content><![CDATA[<h2 id="A-整理字符串"><a href="#A-整理字符串" class="headerlink" title="A.整理字符串"></a>A.<a href="https://leetcode-cn.com/problems/make-the-string-great/">整理字符串</a></h2><p><font size=4><strong>解题思路：</strong></font><br>多次遍历数组，将前后字符ASCII码差值为32的两个字符删除，直到本次遍历没有改变数组。<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">makeGood</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size()==<span class="number">0</span> || s.size()==<span class="number">1</span>)  <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">bool</span> tmp=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size()<span class="number">-1</span>;)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">fabs</span>(s[i]-s[i+<span class="number">1</span>])==<span class="number">32</span>)&#123;</span><br><span class="line">                    tmp=<span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span>(i==<span class="number">0</span> &amp;&amp; s.size()==<span class="number">2</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">                    <span class="keyword">else</span> s.erase(i,<span class="number">2</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>   i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!tmp) <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="B-找出第-N-个二进制字符串中的第-K-位"><a href="#B-找出第-N-个二进制字符串中的第-K-位" class="headerlink" title="B.找出第 N 个二进制字符串中的第 K 位"></a>B.<a href="https://leetcode-cn.com/problems/find-kth-bit-in-nth-binary-string/">找出第 N 个二进制字符串中的第 K 位</a></h2><p><font size=4><strong>解题思路：</strong></font><br>模拟。每次长度变为原来的两倍+1。<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">2000000</span>];</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">findKthBit</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        s[<span class="number">1</span>]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            s[t+<span class="number">1</span>]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=t;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[j] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                    s[j+t+<span class="number">1</span>] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    s[j+t+<span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> <span class="keyword">n_t</span> =  t*<span class="number">2</span> +<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;(<span class="keyword">n_t</span> - t<span class="number">-2</span>)/<span class="number">2</span>;j++)&#123;</span><br><span class="line">                swap(s[t+<span class="number">2</span>+j],s[<span class="keyword">n_t</span>-j]);</span><br><span class="line">            &#125;</span><br><span class="line">            t = <span class="keyword">n_t</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="C-和为目标值的最大数目不重叠非空子数组数目"><a href="#C-和为目标值的最大数目不重叠非空子数组数目" class="headerlink" title="C.和为目标值的最大数目不重叠非空子数组数目"></a>C.<a href="https://leetcode-cn.com/problems/maximum-number-of-non-overlapping-subarrays-with-sum-equals-target/">和为目标值的最大数目不重叠非空子数组数目</a></h2><p><font size=4><strong>解题思路：</strong></font><br>先计算出数组的前缀和，对于第i个前缀和从0<code>~</code>i-1的前缀和找到是否有tmp = sum[i]-target。如果找到sum[j] = tmp，则找到区间j+1<code>~</code>i的区间和为target。（区间不重叠问题）最后将所有满足的区间，按右端点从小到大排序，按序选择不重叠的区间，返回区间数。<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; x,<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x.second != y.second)    <span class="keyword">return</span> x.second &lt; y.second;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> x.first&lt;y.first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sum;</span><br><span class="line">    <span class="built_in">vector</span>&lt; <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; seg;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxNonOverlapping</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        sum.resize(n);</span><br><span class="line">        sum[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            sum[i] = nums[i]+sum[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = sum[i] -target;</span><br><span class="line">            <span class="keyword">if</span>(q[tmp]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                seg.push_back(&#123;q[tmp],i&#125;);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!tmp)&#123;</span><br><span class="line">                seg.push_back(&#123;<span class="number">0</span>,i&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            q[sum[i]] = i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> nseg = seg.size();</span><br><span class="line">        sort(seg.begin(),seg.end(),cmp);</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>,n_r=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nseg;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> l = seg[i].first;</span><br><span class="line">            <span class="keyword">if</span>(l&gt;n_r)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                n_r = seg[i].second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="D-切棍子的最小成本"><a href="#D-切棍子的最小成本" class="headerlink" title="D.切棍子的最小成本"></a>D.<a href="https://leetcode-cn.com/problems/minimum-cost-to-cut-a-stick/">切棍子的最小成本</a></h2><p><font size=4><strong>解题思路：</strong></font><br>区间DP，预处理前缀和。dp[i] [j] 表示在当前待切割的木棍的左端点为 cuts[i−1]，右端点为 cuts[j] 时，将木棍全部切开的最小总成本。dp[i] [j] = min(dp[i] [j],dp[i] [k]+dp[k+1] [j]+sum[j]-sum[i-1])<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cuts)</span> </span>&#123;</span><br><span class="line">        sort(cuts.begin(),cuts.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; len_ele;</span><br><span class="line">        len_ele.push_back(<span class="number">0</span>);</span><br><span class="line">        len_ele.push_back(cuts[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;cuts.size();i++)</span><br><span class="line">            len_ele.push_back(cuts[i]-cuts[i<span class="number">-1</span>]);</span><br><span class="line">        len_ele.push_back(n-cuts[cuts.size()<span class="number">-1</span>]);</span><br><span class="line">        n = len_ele.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sum</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            sum[i] = sum[i<span class="number">-1</span>] + len_ele[i];</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n+<span class="number">2</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">2</span>,<span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">1</span>;len&lt;n ;len ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i+len&lt;=n;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> j = i+len;</span><br><span class="line">                dp[i][j] = INT_MAX;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k+<span class="number">1</span>&lt;=j;k++)&#123;</span><br><span class="line">                    dp[i][j] = min(dp[i][j],dp[i][k]+dp[k+<span class="number">1</span>][j]+sum[j]-sum[i<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><font size=5><strong>做题情况：</strong></font><br>AC 三题<br>排名：674 / 5614<br><font size=5><strong>总结反思：</strong></font><br>排名很差，比赛中第四题并没有成功AC，归结于之前没怎么写过区间DP。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>【Leetcode】第213场周赛</title>
    <url>/2020/11/01/weekcontest-213/</url>
    <content><![CDATA[<h2 id="A-能否连接形成数组"><a href="#A-能否连接形成数组" class="headerlink" title="A.能否连接形成数组"></a>A.<a href="https://leetcode-cn.com/problems/check-array-formation-through-concatenation/">能否连接形成数组</a></h2><p><font size=4><strong>解题思路：</strong></font><br>暴力。从第一位开始枚举，如果piece[i] 可以满足，则加上piece[i] 的长度继续枚举。<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr,vis;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pieces;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">bool</span> tmp;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFormArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; pieces)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;arr = arr;</span><br><span class="line">        <span class="keyword">this</span>-&gt;pieces = pieces;</span><br><span class="line">        n = arr.size();</span><br><span class="line">        tmp = <span class="literal">false</span>;</span><br><span class="line">        m = pieces.size();</span><br><span class="line">        vis.resize(m,<span class="literal">false</span>);</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isok</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; pieces[t].size();i++)</span><br><span class="line">            <span class="keyword">if</span>(pieces[t][i] != arr[k + i])  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k &gt;= n)&#123;</span><br><span class="line">            tmp = <span class="literal">true</span>; <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[i] &amp;&amp; isok(k,i))&#123;</span><br><span class="line">                vis[i] = <span class="literal">true</span>;</span><br><span class="line">                dfs(k + pieces[i].size());</span><br><span class="line">                vis[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="B-统计字典序元音字符串的数目"><a href="#B-统计字典序元音字符串的数目" class="headerlink" title="B.统计字典序元音字符串的数目"></a>B.<a href="https://leetcode-cn.com/problems/count-sorted-vowel-strings/">统计字典序元音字符串的数目</a></h2><p><font size=4><strong>解题思路：</strong></font><br>动态规划。dp[i] [0], dp[i] [1] ……dp[i] [4]，记为长度为 i 的字符串为a,e,i,o,u开头的合法字符串个数。所以递推公式为：<br>$$<br>dp[i][j] = \sum\limits_{k=j}^4dp[i-1][k]<br>$$<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countVowelStrings</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">55</span>][<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)    dp[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">5</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = j;k &lt; <span class="number">5</span>;k++)</span><br><span class="line">                    dp[i][j] += dp[i<span class="number">-1</span>][k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)    ans += dp[n][i];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="C-可以到达的最远建筑"><a href="#C-可以到达的最远建筑" class="headerlink" title="C.可以到达的最远建筑"></a>C.<a href="https://leetcode-cn.com/problems/furthest-building-you-can-reach/">可以到达的最远建筑</a></h2><p><font size=4><strong>解题思路：</strong></font><br>贪心，优先队列。从左往右的移动，优先使用砖头，当砖头不够用时，如果无梯子，则当前位置即为能到达最远位置，如果有梯子，将到下一个位置所需要的砖头数与之前每一次使用的砖头数的大值替换成梯子，用优先队列存放每次使用的砖头数。<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">furthestBuilding</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights, <span class="keyword">int</span> bricks, <span class="keyword">int</span> ladders)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">priority_queue</span> &lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line">        <span class="keyword">int</span> n = heights.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n - <span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(heights[i] &gt;= heights[i + <span class="number">1</span>])    <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> x = heights[i + <span class="number">1</span>] - heights[i];</span><br><span class="line">            <span class="keyword">if</span>(x &lt;= bricks)&#123;</span><br><span class="line">                q.push(x);</span><br><span class="line">                bricks -= x;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                bricks -= x;</span><br><span class="line">                <span class="keyword">if</span>(ladders--)&#123;</span><br><span class="line">                    q.push(x);</span><br><span class="line">                    bricks += q.top();</span><br><span class="line">                    q.pop();</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="D-第-K-条最小指令"><a href="#D-第-K-条最小指令" class="headerlink" title="D.第 K 条最小指令"></a>D.<a href="https://leetcode-cn.com/problems/kth-smallest-instructions/">第 K 条最小指令</a></h2><p><font size=4><strong>解题思路：</strong></font><br>组合数学。优先确定高位，用组合数算出以H为高位接下来有t种方案，如果t&gt;=k，则确定高位为H，否则为V，如果为V则减去以H为高位的所有方案。</p>
<p><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> k,cnt;</span><br><span class="line">    <span class="built_in">string</span> res;</span><br><span class="line">    ll dp[<span class="number">50</span>][<span class="number">50</span>];</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">kthSmallestPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; destination, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>]=dp[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">30</span>;++i)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=dp[i][i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;++j)&#123;</span><br><span class="line">                dp[i][j]=dp[i<span class="number">-1</span>][j]+dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> r = destination[<span class="number">0</span>], c = destination[<span class="number">1</span>]; <span class="comment">//r个V c个H</span></span><br><span class="line">        <span class="keyword">int</span> n = r + c; </span><br><span class="line">        res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!c)  &#123;</span><br><span class="line">                res += <span class="string">&#x27;V&#x27;</span>;<span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!r)  &#123;</span><br><span class="line">                res += <span class="string">&#x27;H&#x27;</span>;<span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ll t = dp[r+c<span class="number">-1</span>][c<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(t &gt;= k)&#123;</span><br><span class="line">                res += <span class="string">&#x27;H&#x27;</span>;</span><br><span class="line">                c--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                k -= t;</span><br><span class="line">                res += <span class="string">&#x27;V&#x27;</span>;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><font size=5><strong>做题情况：</strong></font><br>AC 三题<br>排名：351 / 3826</p>
<p><font size=5><strong>总结反思：</strong></font><br>第三题忘记把当前的使用砖头数减去，导致wa了一发。第四题一开始想到的是递归回溯的方法，写了半天T了。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>贪心</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>C#部分用法整理</title>
    <url>/2020/12/04/summary-of-CSHARP/</url>
    <content><![CDATA[<h2 id="1、输出"><a href="#1、输出" class="headerlink" title="1、输出"></a>1、输出</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Console.WriteLine(<span class="string">&quot;输出&quot;</span>); <span class="comment">//控制台输出</span></span><br><span class="line"></span><br><span class="line">Console.WriteLine(格式字符串(含替代标记),替换值<span class="number">0</span>,替换值<span class="number">1</span>,替换值<span class="number">2</span>,...);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;两个整数示例是 &#123;0&#125; 和 &#123;1&#125;&quot;</span>,<span class="number">3</span>,<span class="number">6</span>);</span><br><span class="line"><span class="comment">//输出结果为：两个整数示例是 3 和 6</span></span><br></pre></td></tr></table></figure>



<h2 id="2、计时"><a href="#2、计时" class="headerlink" title="2、计时"></a>2、计时</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">DateTime beforeDT = System.DateTime.Now; <span class="comment">//获取开始时间</span></span><br><span class="line">程序段</span><br><span class="line">DateTime afterDT = System.DateTime.Now; <span class="comment">//获取结束时间</span></span><br><span class="line">TimeSpan ts = afterDT.Subtract(beforeDT); <span class="comment">//结束时间减去开始时间</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;DateTime costed for Shuffle function is: &#123;0&#125;ms&quot;</span>, ts.TotalMilliseconds); <span class="comment">//控制台输出时间</span></span><br></pre></td></tr></table></figure>



<h2 id="3、多线程"><a href="#3、多线程" class="headerlink" title="3、多线程"></a>3、多线程</h2><h4 id="3-1-创建并启动线程"><a href="#3-1-创建并启动线程" class="headerlink" title="3.1 创建并启动线程"></a>3.1 创建并启动线程</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Thread socketLine = <span class="keyword">new</span> Thread(Recieve_Message); <span class="comment">//创建线程 线程执行Recieve_Message这个函数</span></span><br><span class="line">socketLine.Start();<span class="comment">//启动线程</span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-线程信号量"><a href="#3-2-线程信号量" class="headerlink" title="3.2 线程信号量"></a>3.2 线程信号量</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> ManualResetEvent mresend = <span class="keyword">new</span> ManualResetEvent(<span class="literal">false</span>); <span class="comment">//创建一个信号量，初始状态为False</span></span><br><span class="line"></span><br><span class="line">mresend.WaitOne(); <span class="comment">//等待信号，如果信号是False则阻塞</span></span><br><span class="line">mresend.Set(); <span class="comment">//将信号设为True，允许阻塞的经常恢复</span></span><br><span class="line">mresend.Reset(); <span class="comment">//将信号设为Fasle</span></span><br></pre></td></tr></table></figure>



<h2 id="4、定时"><a href="#4、定时" class="headerlink" title="4、定时"></a>4、定时</h2><h4 id="4-1-定时器控件"><a href="#4-1-定时器控件" class="headerlink" title="4.1 定时器控件"></a>4.1 定时器控件</h4><p>定义在System.Windows.Forms里,占用主线程执行定时器功能</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在From中添加控件，然后在timer_Tick方法中，实现定时器的功能</span></span><br><span class="line">timer.Interval = <span class="number">1500</span>; <span class="comment">//定时器时间,单位为ms</span></span><br><span class="line">timer.Enabled = <span class="literal">true</span>; <span class="comment">//是否执行timer_Tick方法</span></span><br></pre></td></tr></table></figure>

<h4 id="4-2-定时器类"><a href="#4-2-定时器类" class="headerlink" title="4.2 定时器类"></a>4.2 定时器类</h4><p>定义在System.Timers.Timer类里,不占用主线程。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实例化Timer类，设置间隔时间为1000毫秒； </span></span><br><span class="line">System.Timers.Timer t = <span class="keyword">new</span> System.Timers.Timer(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//到达时间的时候执行事件；</span></span><br><span class="line">t.Elapsed += <span class="keyword">new</span> System.Timers.ElapsedEventHandler(theout); </span><br><span class="line">t.AutoReset = <span class="literal">true</span>;<span class="comment">//设置是执行一次（false）还是一直执行(true)； </span></span><br><span class="line">t.Enabled = <span class="literal">true</span>;<span class="comment">//是否执行System.Timers.Timer.Elapsed事件；</span></span><br></pre></td></tr></table></figure>



<h2 id="5、文件"><a href="#5、文件" class="headerlink" title="5、文件"></a>5、文件</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span> path = System.AppDomain.CurrentDomain.BaseDirectory + <span class="string">&quot;parameter.txt&quot;</span>; <span class="comment">//文件路径</span></span><br><span class="line">File.Exists(@path) <span class="comment">//文件是否存在</span></span><br><span class="line">File.Create(@path) <span class="comment">//创建文件</span></span><br><span class="line">FileStream fs = <span class="keyword">new</span> FileStream(path, FileMode.Open); <span class="comment">//创建文件流</span></span><br><span class="line">fs.Seek(x, SeekOrigin.Begin); <span class="comment">//设置文件流的起始位置为x</span></span><br><span class="line">fs.Write(data, <span class="number">0</span>, data.Length); <span class="comment">//文件写入</span></span><br><span class="line">fs.Close(); <span class="comment">//文件流关闭</span></span><br></pre></td></tr></table></figure>



<h2 id="6、绘图"><a href="#6、绘图" class="headerlink" title="6、绘图"></a>6、绘图</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Graphics g = <span class="keyword">this</span>.panel1.CreateGraphics(); <span class="comment">//创建绘画类</span></span><br><span class="line">Pen p1 = <span class="keyword">new</span> Pen(Color.Yellow, <span class="number">0.2f</span>); <span class="comment">//创建画笔，设置颜色大小</span></span><br><span class="line">g.Clear(Color.White); <span class="comment">//清空成白色</span></span><br><span class="line">g.DrawLine(p1, <span class="keyword">new</span> PointF(x1, y2), <span class="keyword">new</span> PointF(x2, y2)); <span class="comment">//用p1画笔画一条线段从(x1,y1)到(x2,y2)</span></span><br><span class="line">g.DrawEllipse(p1, x, y, w, h); <span class="comment">//用p1画笔画一个椭圆，椭圆边框左上角坐标为(x,y),椭圆宽度为w，高度为h</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程语言</category>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
</search>
