<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【Leetcode】第199场周赛</title>
    <url>/2020/07/28/%E3%80%90Leetcode%E3%80%91%E7%AC%AC199%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
    <content><![CDATA[<h2 id="A-重新排列字符串"><a href="#A-重新排列字符串" class="headerlink" title="A.重新排列字符串"></a>A.<a href="https://leetcode-cn.com/problems/shuffle-string/">重新排列字符串</a></h2><p><font size=4><strong>解题思路：</strong></font><br>开个新数组或者map存储对应序号的字符，然后按序输出。<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">restoreString</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; indices)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">char</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">            q[indices[i]]=s[i];</span><br><span class="line">        <span class="built_in">string</span> ans=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">            ans+=q[i];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="B-灯泡开关-IV"><a href="#B-灯泡开关-IV" class="headerlink" title="B.灯泡开关 IV"></a>B.<a href="https://leetcode-cn.com/problems/bulb-switcher-iv/">灯泡开关 IV</a></h2><p><font size=4><strong>解题思路：</strong></font><br>遍历灯泡数组，从前往后翻转，如果前一状态与此时状态不同，则翻转灯泡。<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minFlips</span><span class="params">(<span class="built_in">string</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> tmp[<span class="number">2</span>]=&#123;<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;target.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target[i]!=tmp[t])&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                t=<span class="number">1</span>-t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="C-好叶子节点对的数量"><a href="#C-好叶子节点对的数量" class="headerlink" title="C.好叶子节点对的数量"></a>C.<a href="https://leetcode-cn.com/problems/number-of-good-leaf-nodes-pairs/">好叶子节点对的数量</a></h2><p><font size=4><strong>解题思路：</strong></font><br>后序遍历树，每个节点返回该节点的子树中距离该节点i长度的叶节点个数的vector数组。<br>答案计算在每个节点中，加上该节点左右子树叶节点距离&lt;=distance个数的乘积和。<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans,d;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPairs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> distance)</span> </span>&#123;</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        d=distance;</span><br><span class="line">        order(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">order</span><span class="params">(TreeNode *T)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(T==<span class="literal">NULL</span>)     <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; (d+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;left==<span class="literal">NULL</span> &amp;&amp; T-&gt;right==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">q</span><span class="params">(d+<span class="number">1</span>)</span></span>;</span><br><span class="line">            q[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; le = order(T-&gt;left);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ri = order(T-&gt;right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=d;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            le[i]=le[i<span class="number">-1</span>];</span><br><span class="line">            ri[i]=ri[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        le[<span class="number">0</span>]=ri[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=d;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=d;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i+j&lt;=d)  ans+=le[i]*ri[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=d;i++)</span><br><span class="line">            le[i]+=ri[i];</span><br><span class="line">        <span class="keyword">return</span> le;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><font size=5><strong>做题情况：</strong></font><br>AC 三题<br>排名：154 / 5231<br><font size=5><strong>总结反思：</strong></font><br>这次排名较高，第三题思路出的比较快，之前几次都要八百多名，继续努力，坚持每日一刷题，争取周赛能够AK。<br>第一次写博客，以后要多写博客，分享一些做题或者学习的情况与反思。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>深度优先遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>【Leetcode】第200场周赛</title>
    <url>/2020/08/31/%E3%80%90Leetcode%E3%80%91%E7%AC%AC200%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
    <content><![CDATA[<h2 id="A-统计好三元组"><a href="#A-统计好三元组" class="headerlink" title="A.统计好三元组"></a>A.<a href="https://leetcode-cn.com/problems/count-good-triplets/">统计好三元组</a></h2><p><font size=4><strong>解题思路：</strong></font><br>三重遍历所有情况。判断三元组是否满足条件。<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countGoodTriplets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>,n=arr.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=j+<span class="number">1</span>;k&lt;n;k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">fabs</span>(arr[i]-arr[j])&lt;=a &amp;&amp; <span class="built_in">fabs</span>(arr[j]-arr[k])&lt;=b&amp;&amp;<span class="built_in">fabs</span>(arr[k]-arr[i])&lt;=c)</span><br><span class="line">                        ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="B-找出数组游戏的赢家"><a href="#B-找出数组游戏的赢家" class="headerlink" title="B.找出数组游戏的赢家"></a>B.<a href="https://leetcode-cn.com/problems/find-the-winner-of-an-array-game/">找出数组游戏的赢家</a></h2><p><font size=4><strong>解题思路：</strong></font><br>将数组转换成链表，模拟游戏过程。<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    node *next;</span><br><span class="line">    node(<span class="keyword">int</span> x)&#123;v=x;next=<span class="literal">nullptr</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getWinner</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=arr.size();</span><br><span class="line">        <span class="keyword">if</span>(k&gt;n)&#123;</span><br><span class="line">            <span class="keyword">int</span> maxv=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)    maxv=max(maxv,arr[i]);</span><br><span class="line">            <span class="keyword">return</span> maxv;</span><br><span class="line">        &#125;</span><br><span class="line">        node *root = <span class="keyword">new</span> node(arr[<span class="number">0</span>]);</span><br><span class="line">        node *p;p=root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            node *q = <span class="keyword">new</span> node(arr[i]);</span><br><span class="line">            p-&gt;next=q;</span><br><span class="line">            p=q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t==k)&#123;</span><br><span class="line">                <span class="keyword">return</span> root-&gt;v;</span><br><span class="line">            &#125;</span><br><span class="line">            node *q=root-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;v &gt; q-&gt;v)&#123;</span><br><span class="line">                t++;</span><br><span class="line">                p-&gt;next = q;</span><br><span class="line">                root-&gt;next = q-&gt;next;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                t=<span class="number">1</span>;</span><br><span class="line">                p-&gt;next = root;</span><br><span class="line">                root = q;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="C-排布二进制网格的最少交换次数"><a href="#C-排布二进制网格的最少交换次数" class="headerlink" title="C.排布二进制网格的最少交换次数"></a>C.<a href="https://leetcode-cn.com/problems/minimum-swaps-to-arrange-a-binary-grid/">排布二进制网格的最少交换次数</a></h2><p><font size=4><strong>解题思路：</strong></font><br>统计每行末尾有几个0。从0行开始，判断每一行的尾0是否满足，不满足则从后面找到最先满足的一行一行交换上来，同时ans++。最后判断网格是否满足上三角，不满足输入-1，满足输出ans。<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSwaps</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size();</span><br><span class="line">        <span class="comment">//cout&lt;&lt;n&lt;&lt;endl;</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">zenum</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=n<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="number">0</span>)   zenum[i]++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for(int i=0;i&lt;n;i++) cout&lt;&lt;zenum[i]&lt;&lt;&quot; &quot;;</span></span><br><span class="line">        <span class="comment">// cout&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(zenum[i]&gt;=n<span class="number">-1</span>-i) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(zenum[j]&gt;=n-i<span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k=j;k!=i;k--)&#123;</span><br><span class="line">                        swap(zenum[k],zenum[k<span class="number">-1</span>]);</span><br><span class="line">                        ans++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(zenum[i]&lt;n<span class="number">-1</span>-i)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="D-最大得分"><a href="#D-最大得分" class="headerlink" title="D.最大得分"></a>D.<a href="https://leetcode-cn.com/problems/get-the-maximum-score/">最大得分</a></h2><p><font size=4><strong>解题思路：</strong></font><br>按数组建图，在图上dfs。<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mymax(a,b)(a&gt;b?a:b)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2e5</span>+<span class="number">50</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,next;</span><br><span class="line">&#125;edges[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,tot,head[maxn],w[maxn];</span><br><span class="line">ll dp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    ++tot;</span><br><span class="line">    edges[tot].to=v;</span><br><span class="line">    edges[tot].next=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dp[u]) <span class="keyword">return</span> dp[u];</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=edges[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=edges[i].to;</span><br><span class="line">        ans=mymax(ans,dfs(v));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[u]=ans+w[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(edges,<span class="number">0</span>, <span class="keyword">sizeof</span>(edges));</span><br><span class="line">    <span class="built_in">memset</span>(w,<span class="number">0</span>,<span class="keyword">sizeof</span>(w));</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">    n=tot=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; getid;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> e:nums1)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!getid[e])&#123;</span><br><span class="line">                getid[e]=++cnt;</span><br><span class="line">                w[cnt]=e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> e:nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!getid[e])&#123;</span><br><span class="line">                getid[e]=++cnt;</span><br><span class="line">                w[cnt]=e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        n=cnt;</span><br><span class="line">        <span class="keyword">int</span> len1=nums1.size();</span><br><span class="line">        <span class="keyword">int</span> len2=nums2.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+<span class="number">1</span>&lt;len1;++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> u=getid[nums1[i]],v=getid[nums1[i+<span class="number">1</span>]];</span><br><span class="line">            addedge(u,v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+<span class="number">1</span>&lt;len2;++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> u=getid[nums2[i]],v=getid[nums2[i+<span class="number">1</span>]];</span><br><span class="line">            addedge(u,v);</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans=mymax(dfs(getid[nums1[<span class="number">0</span>]]),dfs(getid[nums2[<span class="number">0</span>]]));</span><br><span class="line">        <span class="keyword">return</span> ans%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><font size=5><strong>做题情况：</strong></font><br>AC 三题<br>排名：792 / 5475<br><font size=5><strong>总结反思：</strong></font><br>排名很差，第四题比赛内没有AC，有思路，一开始思路有点问题，写的不是很熟练。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>深度优先遍历</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>【Leetcode】第201场周赛</title>
    <url>/2020/09/01/%E3%80%90Leetcode%E3%80%91%E7%AC%AC201%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
    <content><![CDATA[<h2 id="A-整理字符串"><a href="#A-整理字符串" class="headerlink" title="A.整理字符串"></a>A.<a href="https://leetcode-cn.com/problems/make-the-string-great/">整理字符串</a></h2><p><font size=4><strong>解题思路：</strong></font><br>多次遍历数组，将前后字符ASCII码差值为32的两个字符删除，直到本次遍历没有改变数组。<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">makeGood</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size()==<span class="number">0</span> || s.size()==<span class="number">1</span>)  <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">bool</span> tmp=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size()<span class="number">-1</span>;)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">fabs</span>(s[i]-s[i+<span class="number">1</span>])==<span class="number">32</span>)&#123;</span><br><span class="line">                    tmp=<span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span>(i==<span class="number">0</span> &amp;&amp; s.size()==<span class="number">2</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">                    <span class="keyword">else</span> s.erase(i,<span class="number">2</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>   i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!tmp) <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="B-找出第-N-个二进制字符串中的第-K-位"><a href="#B-找出第-N-个二进制字符串中的第-K-位" class="headerlink" title="B.找出第 N 个二进制字符串中的第 K 位"></a>B.<a href="https://leetcode-cn.com/problems/find-kth-bit-in-nth-binary-string/">找出第 N 个二进制字符串中的第 K 位</a></h2><p><font size=4><strong>解题思路：</strong></font><br>模拟。每次长度变为原来的两倍+1。<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">2000000</span>];</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">findKthBit</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        s[<span class="number">1</span>]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            s[t+<span class="number">1</span>]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=t;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[j] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                    s[j+t+<span class="number">1</span>] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    s[j+t+<span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> <span class="keyword">n_t</span> =  t*<span class="number">2</span> +<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;(<span class="keyword">n_t</span> - t<span class="number">-2</span>)/<span class="number">2</span>;j++)&#123;</span><br><span class="line">                swap(s[t+<span class="number">2</span>+j],s[<span class="keyword">n_t</span>-j]);</span><br><span class="line">            &#125;</span><br><span class="line">            t = <span class="keyword">n_t</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="C-和为目标值的最大数目不重叠非空子数组数目"><a href="#C-和为目标值的最大数目不重叠非空子数组数目" class="headerlink" title="C.和为目标值的最大数目不重叠非空子数组数目"></a>C.<a href="https://leetcode-cn.com/problems/maximum-number-of-non-overlapping-subarrays-with-sum-equals-target/">和为目标值的最大数目不重叠非空子数组数目</a></h2><p><font size=4><strong>解题思路：</strong></font><br>先计算出数组的前缀和，对于第i个前缀和从0<code>~</code>i-1的前缀和找到是否有tmp = sum[i]-target。如果找到sum[j] = tmp，则找到区间j+1<code>~</code>i的区间和为target。（区间不重叠问题）最后将所有满足的区间，按右端点从小到大排序，按序选择不重叠的区间，返回区间数。<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; x,<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x.second != y.second)    <span class="keyword">return</span> x.second &lt; y.second;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> x.first&lt;y.first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sum;</span><br><span class="line">    <span class="built_in">vector</span>&lt; <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; seg;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxNonOverlapping</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        sum.resize(n);</span><br><span class="line">        sum[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            sum[i] = nums[i]+sum[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = sum[i] -target;</span><br><span class="line">            <span class="keyword">if</span>(q[tmp]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                seg.push_back(&#123;q[tmp],i&#125;);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!tmp)&#123;</span><br><span class="line">                seg.push_back(&#123;<span class="number">0</span>,i&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            q[sum[i]] = i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> nseg = seg.size();</span><br><span class="line">        sort(seg.begin(),seg.end(),cmp);</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>,n_r=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nseg;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> l = seg[i].first;</span><br><span class="line">            <span class="keyword">if</span>(l&gt;n_r)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                n_r = seg[i].second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="D-切棍子的最小成本"><a href="#D-切棍子的最小成本" class="headerlink" title="D.切棍子的最小成本"></a>D.<a href="https://leetcode-cn.com/problems/minimum-cost-to-cut-a-stick/">切棍子的最小成本</a></h2><p><font size=4><strong>解题思路：</strong></font><br>区间DP，预处理前缀和。dp[i] [j] 表示在当前待切割的木棍的左端点为 cuts[i−1]，右端点为 cuts[j] 时，将木棍全部切开的最小总成本。dp[i] [j] = min(dp[i] [j],dp[i] [k]+dp[k+1] [j]+sum[j]-sum[i-1])<br><font size=4><strong>代码展示：</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cuts)</span> </span>&#123;</span><br><span class="line">        sort(cuts.begin(),cuts.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; len_ele;</span><br><span class="line">        len_ele.push_back(<span class="number">0</span>);</span><br><span class="line">        len_ele.push_back(cuts[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;cuts.size();i++)</span><br><span class="line">            len_ele.push_back(cuts[i]-cuts[i<span class="number">-1</span>]);</span><br><span class="line">        len_ele.push_back(n-cuts[cuts.size()<span class="number">-1</span>]);</span><br><span class="line">        n = len_ele.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sum</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            sum[i] = sum[i<span class="number">-1</span>] + len_ele[i];</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n+<span class="number">2</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">2</span>,<span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">1</span>;len&lt;n ;len ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i+len&lt;=n;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> j = i+len;</span><br><span class="line">                dp[i][j] = INT_MAX;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k+<span class="number">1</span>&lt;=j;k++)&#123;</span><br><span class="line">                    dp[i][j] = min(dp[i][j],dp[i][k]+dp[k+<span class="number">1</span>][j]+sum[j]-sum[i<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><font size=5><strong>做题情况：</strong></font><br>AC 三题<br>排名：674 / 5614<br><font size=5><strong>总结反思：</strong></font><br>排名很差，比赛中第四题并没有成功AC，归结于之前没怎么写过区间DP。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
</search>
